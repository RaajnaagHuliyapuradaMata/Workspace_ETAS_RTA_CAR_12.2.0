/*******************************************************************************
 * Autogenerated by MCALgen for CAN V3.0.51.35438: Can_Device.cpp
 *******************************************************************************/

extern "C" {
  #include "Can.h"
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"
#endif
  #include "Os.h"
  #include "Can_Implementation.h"
}
#include "virtualDevice.hpp"
#include "Can_Device.hpp"


#define CAN_APIS     "None|Can_Init|Can_MainfunctionWrite|Can_InitController|Can_SetMode|"\
                     "Can_DisableInterrupts|Can_EnableInterrupts|Can_Write|Can_GetVersionInfo|"\
                     "Can_MainfunctionRead|Can_MainfunctionBusoff|Can_MainfunctionWakeup|Can_CheckWakeup|"\
                     "Can_MainfunctionMode|Can_SetBaudrate|"\
                     "Can_DeInit|Can_GetControllerMode|Can_GetControllerErrorState|"\
                     "Can_GetControllerRxErrorCounter|Can_GetControllerTxErrorCounter|Can_GetCurrentTime|"\
                     "Can_EnableEgressTimeStamp|Can_GetEgressTimeStamp|Can_GetIngressTimeStamp"

#define CAN_DETS      "None|CAN_E_PARAM_POINTER|CAN_E_PARAM_HANDLE|CAN_E_PARAM_DATA_LENGTH|CAN_E_PARAM_CONTROLLER|"\
                      "CAN_E_UNINIT|CAN_E_TRANSITION|CAN_E_PARAM_BAUDRATE|CAN_E_INIT_FAILED|CAN_E_PARAM_LPDU"

#define CAN_RUNTIME  "None|CAN_E_DATALOST"
//------------------------------------------------------------------------------
class CanControllerDevice :  public VirtualDevice { /* [$CAN 1111]  */
  protected:
    vrtaDevID    _parent;
    uint8        _id;
    uint8        _index;

    struct StatusEventType {vrtaUInt state; char name[1024];};
    struct WriteEventType { vrtaUInt _source; vrtaUInt _result;  vrtaUInt _hth; vrtaUInt _txpduid; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};
    struct TxEventType {vrtaUInt _source;  vrtaUInt _hth; vrtaUInt _txpduid; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};
    struct RxEventType {vrtaUInt _source; vrtaUInt _hrh; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};
    struct CurrentTimeType{vrtaUInt seconds; vrtaUInt nanoseconds;};
    struct EnableEgressTimeStampType{vrtaUInt Hth; vrtaUInt enabled;};
    struct EgressTimeStampType{vrtaUInt TxPduId; vrtaUInt Hth; vrtaUInt seconds; vrtaUInt nanoseconds;};
    struct IngressTimeStampType{vrtaUInt Hrh; vrtaUInt seconds; vrtaUInt nanoseconds;};

    WriteEventType _write;
    TxEventType    _tx;
    RxEventType    _rx;
    StatusEventType _status;
    vrtaUInt _errorState;
    vrtaUInt _RxErrorCount;
    vrtaUInt _TxErrorCount;
    vrtaUInt _error;
    CurrentTimeType _CurrentTime;
    EnableEgressTimeStampType _EnableEgressTimeStamp;
    EgressTimeStampType _EgressTimeStamp;
    IngressTimeStampType _IngressTimeStamp;

  public:
    CanControllerDevice(const char *name, uint8 id, uint8 index, vrtaDevID parent) {
      _parent = parent;
      _id = id;
      _index = index;
      _write._source  = 0;
      _write._result  = 0;
      _write._txpduid = 0;
      _write._hth     = 0;
      _write._id      = 0;
      _write._length  = 0;
      memset(_write._data, 0, CAN_MAX_DATA_LENGTH);
      _rx._source     = 0;
      _rx._hrh        = 0;
      _rx._id         = 0;
      _rx._length     = 0;
      memset(_rx._data, 0, CAN_MAX_DATA_LENGTH);
      _tx._source     = 0;
      _tx._txpduid    = 0;
      _tx._hth        = 0;
      _tx._id         = 0;
      _tx._length     = 0;
      memset(_tx._data, 0, CAN_MAX_DATA_LENGTH);
      _status.state   = 0;
      memcpy(&_status.name[0], "?", 2);
      _errorState     = 0;
      _RxErrorCount   = 0;
      _TxErrorCount   = 0;
      _error                        = 0;
      _CurrentTime.seconds          = 0;
      _CurrentTime.nanoseconds      = 0;
      _EnableEgressTimeStamp.Hth    = 0;
      _EnableEgressTimeStamp.enabled = 0;
      _EgressTimeStamp.TxPduId      = 0;
      _EgressTimeStamp.Hth          = 0;
      _EgressTimeStamp.seconds      = 0;
      _EgressTimeStamp.nanoseconds  = 0;
      _IngressTimeStamp.Hrh         = 0;
      _IngressTimeStamp.seconds     = 0;
      _IngressTimeStamp.nanoseconds = 0;
      RegisterAs(name);
    }

    //------------------------------------------------------------------------------
    void RaiseStateEvent(int index, Can_EventState state, const char* hardwarename) {
      _status.state = state;
      if (hardwarename == NULL_PTR || (strlen(hardwarename)+1 > sizeof(_status.name))){
        strcpy(_status.name, "?");
      }else{
        strcpy(_status.name, hardwarename);
      }
      Raise(EVENT_HANDLER(CanControllerDevice::StateEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseErrorStateEvent(vrtaUInt errorState) {
      _errorState = errorState;
      Raise(EVENT_HANDLER(CanControllerDevice::ErrorStateEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseWriteEvent(int index,  boolean source, uint8 result, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       switch(source) { /* [$CAN 1035] */
         case false: _write._source = 1; break; // fromApi
         case true: _write._source = 2; break; // fromAction
         default: _write._source = 0; break; // None
       }
       switch(result) { /* [$CAN 1026] */
         case CAN_OK: _write._result = 1; break;
         case CAN_NOT_OK: _write._result = 2; break;
         case CAN_BUSY: _write._result = 3; break;
         case CAN_FRAME_DROPPED: _write._result = 4; break;
         default: _write._result = 0; break;
       }
       _write._hth     = handle;
       _write._txpduid = frame->swPduHandle;
       _write._id      = frame->id;
       _write._length  = frame->length;
       memcpy(_write._data, frame->data, _write._length);
       Raise(EVENT_HANDLER(CanControllerDevice::WriteEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       _rx._source  = (uint32)(frame->injected)+1; /* [$CAN 1038] */
       _rx._hrh     = handle;
       _rx._id      = frame->id;
       _rx._length  = frame->length;
       memcpy(_rx._data, frame->data, _rx._length);
       Raise(EVENT_HANDLER(CanControllerDevice::RxEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       _tx._source  = (uint32)(frame->injected)+1; /* [$CAN 1112] */
       _tx._txpduid = frame->swPduHandle;
       _tx._hth     = handle;
       _tx._id      = frame->id;
       _tx._length  = frame->length;
       memcpy(_tx._data, frame->data, _tx._length);
       Raise(EVENT_HANDLER(CanControllerDevice::TxEvent));
    }

    void RaiseRxErrorCounterEvent(uint8 RxErrorCount) {
      _RxErrorCount = RxErrorCount;
      Raise(EVENT_HANDLER(CanControllerDevice::RxErrorCounterEvent));
    }

    void RaiseTxErrorCounterEvent(uint8 TxErrorCount) {
      _TxErrorCount = TxErrorCount;
      Raise(EVENT_HANDLER(CanControllerDevice::TxErrorCounterEvent));
    }

  //------------------------------------------------------------------------------
  void RaiseErrorEvent(vrtaUInt error) {
    _error = error;
    Raise(EVENT_HANDLER(CanControllerDevice::ErrorEvent));
  }

  //------------------------------------------------------------------------------
  void RaiseCurrentTimeEvent(Can_TimeStampType timeStamp) {
    _CurrentTime.seconds = timeStamp.seconds;
    _CurrentTime.nanoseconds = timeStamp.nanoseconds;
    Raise(EVENT_HANDLER(CanControllerDevice::CurrentTimeEvent));
  }

  //------------------------------------------------------------------------------
  void RaiseEnableEgressTimeStampEvent(Can_HwHandleType Hth, vrtaUInt enabled) {
    _EnableEgressTimeStamp.Hth = Hth;
    _EnableEgressTimeStamp.enabled = enabled;
    Raise(EVENT_HANDLER(CanControllerDevice::EnableEgressTimeStampEvent));
  }

  //------------------------------------------------------------------------------
  void RaiseEgressTimeStampEvent ( PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType timeStamp)  {
    _EgressTimeStamp.TxPduId = TxPduId;
    _EgressTimeStamp.Hth = Hth;
    _EgressTimeStamp.seconds = timeStamp.seconds;
    _EgressTimeStamp.nanoseconds = timeStamp.nanoseconds;
    Raise(EVENT_HANDLER(CanControllerDevice::EgressTimeStampEvent));
  }

  //------------------------------------------------------------------------------
  void RaiseIngressTimeStampEvent(Can_HwHandleType Hrh, Can_TimeStampType timeStamp) {
    _IngressTimeStamp.Hrh = Hrh;
    _IngressTimeStamp.seconds = timeStamp.seconds;
    _IngressTimeStamp.nanoseconds = timeStamp.nanoseconds;
    Raise(EVENT_HANDLER(CanControllerDevice::IngressTimeStampEvent));
  }

  protected:
    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the basic information about the device
    void GetDeviceInfo(OptList &info) {
      info.Add("Type", "CanController");
      info.Add("Description", "Implementation of AUTOSAR Can Controller");
      info.Add("Version", "3.0.51");
    }

    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the action handlers and descriptions
    void GetDeviceActions(ActionList &actions) {
      /* [$CAN 1041] */
      ADD_ACTION_HANDLER(CanControllerDevice::DropWriteAction);
      actions.Add("DropWrites", "Drop frames before transmission", "").
      In("Dropwrites","Drop Writes with Can_Write API when true","false|true");

      /* [$CAN 1042] */
      ADD_ACTION_HANDLER(CanControllerDevice::DropReceiveAction);
      actions.Add("DropReceives", "Drop received frames on a controller", "").
      In("Dropreceives","Drop receives on the controller when true","false|true");

       /* [$CAN 1114] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectWriteAction);
      actions.Add("InjectWrite", "Injects a CAN frame to be transmitted on a controller", "").
      In("TxConfirmation","Option to enable or disable txconfirmation","false|true").
      In("Hth","Transmit object handle","%u").
      In("CanTxPduId","Pdu Handle Id","%u").
      In("Id","Frame Id","%u").
      In("Length","Number of bytes of data","%u").
          In("Data","Data bytes","%a:64");
    
      /* [$CAN 1115] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectRxAction);
      actions.Add("InjectRx", "Simulate reception of a specified frame", "").
      In("Hrh","Received object handle","%u").
      In("Id","Frame Id","%u").
      In("Length","Number of bytes of data","%u").
          In("Data","Data bytes","%a:64");
     /* [$CAN 1285] */

      ADD_ACTION_HANDLER(CanControllerDevice::InjectErrorStateAction); /* [$CAN 1282] */
      actions.Add("InjectErrorState", "Inject an error state into the controller to force a BusOff or put controller into passive mode", "").
      In("errorState", "error state to be injected into controller", "Active|Passive|Busoff");

      /* [$CAN 1117] */
      ADD_ACTION_HANDLER(CanControllerDevice::ForceWakeupAction);
      actions.Add("ForceWakeup", "Force the controller to wakeup", "");

      /* [$CAN 1120] */
      ADD_ACTION_HANDLER(CanControllerDevice::StateAction);
      actions.Add("InjectState", "Force the controller to change state", "Raises the state event").
            In("State","Option to change the state of the controller","Uninit|Start|Stop|Sleep");
      

/* [$CAN 1345] [$CAN 1342] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectControllerRxErrorCountAction);
      actions.Add("InjectControllerRxErrorCount", "Inject Rx error count into the controller", "").
      In("RxErrorCount", "error count to be injected into controller", "%u");
/* [$CAN 1346] [$CAN 1349] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectControllerTxErrorCountAction);
      actions.Add("InjectControllerTxErrorCount", "Inject Tx error count into the controller", "").
      In("TxErrorCount", "error count to be injected into controller", "%u");

/* [$CAN 1350] [$CAN 1353] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectErrorAction);
      actions.Add("InjectError", "Inject an error into the controller to force a Can Error", "").
      In("error", "error to be injected into controller", "NoError|BitMonitoring1|BitMonitoring0|Bit|CheckAckFailed|AckDelimiter|ArbitrationLost|Overload|CheckFormFailed|CheckStuffingFailed|CheckCrcFailed|BusLock");
/* [$CAN 1354] [$CAN 1357] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectCurrentTimeAction);
      actions.Add("InjectCurrentTime", "Inject the current time in the controller", "").
      In("seconds", "seconds to be injected into controller", "%u").
      In("nanoseconds", "nanoseconds to be injected into controller", "%u");
/* [$CAN 1358] [$CAN 1361] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectEnableEgressTimeStampAction);
      actions.Add("InjectEnableEgressTimeStamp", "Enable Tx time stamping", "").
      In("Hth", "Hardware Object to enable", "%u").
      In("enable", "Enable or Disable Hardware Object", "false|true");
/* [$CAN 1362] [$CAN 1365] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectEgressTimeStampAction);
      actions.Add("InjectEgressTimeStamp", "Inject a time into a Tx frame", "").
      In("TxPduId", "PDU to time stamp", "%u").
      In("Hth", "Hardware Object to time stamp", "%u").
      In("seconds", "seconds to be injected into frame", "%u").
      In("nanoseconds", "nanoseconds to be injected into frame", "%u");
/* [$CAN 1366] [$CAN 1369] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectIngressTimeStampAction);
      actions.Add("InjectIngressTimeStamp", "Inject a time into a Rx frame", "").
      In("Hrh", "Hardware Object to time stamp", "%u").
      In("seconds", "seconds to be injected into frame", "%u").
      In("nanoseconds", "nanoseconds to be injected into frame", "%u");

    }

    //--------------------------------------------------------------------------
    vrtaErrType DropWriteAction(const vrtaAction &action) {
      vrtaUInt DropWrite;
      UnpackData(action, DropWrite);
      Can_Drop_Write_Action_helper(_index, DropWrite); /* [$CAN 1043] [$CAN 1044] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType DropReceiveAction(const vrtaAction &action) {
      vrtaUInt DropReceive;
      UnpackData(action, DropReceive);
      Can_Drop_Receive_Action_helper(_index, DropReceive); /* [$CAN 1045] [$CAN 1046] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct WriteActionType {vrtaUInt txconfirmation; vrtaUInt hth; vrtaUInt txpduid;  vrtaUInt id; vrtaUInt length; uint8 data[CAN_MAX_DATA_LENGTH];};
    vrtaErrType InjectWriteAction(const vrtaAction &action) {
      WriteActionType write;
      UnpackData(action, write);
      Can_PduType pduInfo;
      pduInfo.swPduHandle = write.txpduid;
      pduInfo.length = write.length;
      pduInfo.id = write.id;
      pduInfo.sdu = write.data;
      Can_Inject_Write_helper(_index, write.hth, &pduInfo, write.txconfirmation, TRUE);  /* [$CAN 1052] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct RxActionType {vrtaUInt hrh; vrtaUInt id; vrtaUInt length; uint8 data[CAN_MAX_DATA_LENGTH];};
    vrtaErrType InjectRxAction(const vrtaAction &action) {
      RxActionType receive;
      UnpackData(action, receive);
      Can_Hwp_Frame frame;
      frame.injected = TRUE;
      frame.txConfirm = FALSE;
      frame.swPduHandle = 0;
      frame.id = receive.id;
      frame.length = receive.length;
      memcpy(frame.data, receive.data, receive.length);
      Can_Inject_Rxaction_helper(_index, receive.hrh, &frame); /* [$CAN 1055] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType InjectErrorStateAction(const vrtaAction &action) {
      Can_ErrorStateType errorState;
      UnpackData(action, errorState);
      Can_injectErrorState(_id, errorState);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType InjectControllerRxErrorCountAction(const vrtaAction &action) {
      uint8 RxErrorCount;
      UnpackData(action, RxErrorCount);
      Can_InjectControllerRxErrorCount(_id, RxErrorCount);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType InjectControllerTxErrorCountAction(const vrtaAction &action) {
      uint8 TxErrorCount;
      UnpackData(action, TxErrorCount);
      Can_InjectControllerTxErrorCount(_id, TxErrorCount);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType InjectErrorAction(const vrtaAction &action) {
      uint8 receive;
      UnpackData(action, receive);
      Can_injectError(_id, receive);
      return RTVECUErr_NONE;
    }
    //--------------------------------------------------------------------------
    struct InjectCurrentTimeActionType {vrtaUInt seconds; vrtaUInt nanoseconds;};
    vrtaErrType InjectCurrentTimeAction(const vrtaAction &action) {
      InjectCurrentTimeActionType receive;
      UnpackData(action, receive);
      Can_TimeStampType timeStamp;
      timeStamp.seconds = receive.seconds;
      timeStamp.nanoseconds = receive.nanoseconds;
      Can_InjectCurrentTime(_id, timeStamp);
      return RTVECUErr_NONE;
    }

    struct InjectEnableEgressTimeStampActionType {vrtaUInt Hth; vrtaUInt enabled;};
    //--------------------------------------------------------------------------
    vrtaErrType InjectEnableEgressTimeStampAction(const vrtaAction &action) {
      InjectEnableEgressTimeStampActionType receive;
      UnpackData(action, receive);
      Can_InjectEnableEgressTimeStamp(receive.Hth, receive.enabled);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct InjectEgressTimeStampActionType {vrtaUInt TxPduId; vrtaUInt Hth; vrtaUInt seconds; vrtaUInt nanoseconds;};
    vrtaErrType InjectEgressTimeStampAction(const vrtaAction &action) {
      InjectEgressTimeStampActionType receive;
      UnpackData(action, receive);
      Can_TimeStampType timeStamp;
      timeStamp.seconds = receive.seconds;
      timeStamp.nanoseconds = receive.nanoseconds;
      Can_InjectEgressTimeStamp(receive.TxPduId ,receive.Hth, timeStamp);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct InjectIngressTimeStampActionType {vrtaUInt Hth; vrtaUInt seconds; vrtaUInt nanoseconds;};
    vrtaErrType InjectIngressTimeStampAction(const vrtaAction &action) {
      InjectIngressTimeStampActionType receive;
      UnpackData(action, receive);
      Can_TimeStampType timeStamp;
      timeStamp.seconds = receive.seconds;
      timeStamp.nanoseconds = receive.nanoseconds;
      Can_InjectIngressTimeStamp(receive.Hth, timeStamp);
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType ForceWakeupAction(const vrtaAction &action) {
      Can_Force_Wakeup(_id ); /* [$CAN 1119] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateAction(const vrtaAction &action) {
      vrtaUInt state;
            Can_ControllerStateType canState;
      UnpackData(action, state);
      canState = (Can_ControllerStateType)state;
            Can_SetControllerMode_helper(_id, canState, TRUE); /* [$CAN 1122] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the event handlers and descriptions
    void GetDeviceEvents(EventList &events) {
      /* [$CAN 1022] */
      ADD_EVENT_HANDLER(CanControllerDevice::StateEvent);
        events.Add("State",  "Can controller state", "Poll,Raise").
          Out("State", "Can controller State", "Uninit|Stopped|Started|Sleep").
          Out("Name", "Can controller name","%s");
      ADD_EVENT_HANDLER(CanControllerDevice::Parent);
        events.Add("_Parent", "ID of the Device that owns this device", "Poll").
          Out("Id", "Parent ID", "%u");
      /* [$CAN 1024] */
      ADD_EVENT_HANDLER(CanControllerDevice::WriteEvent);
        events.Add("Write",  "Returns the last written frame", "Poll,Raise").
          Out("Source","Raised from an action or API","None|Api|Action").
          Out("Result","Last Transmit result","None|Ok|NotOk|Busy|Dropped").
          Out("Hth","Transmit object handle","%u").
          Out("CanTxPduId","Pdu Handle Id","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
      /* [$CAN 1030] */
      ADD_EVENT_HANDLER(CanControllerDevice::TxEvent);
        events.Add("Tx",  "Returns the last completed transmit frame", "Poll,Raise").
          Out("Source", "Raised from an action or API", "None|Api|Action").
          Out("Hth","Transmit object handle","%u").
          Out("CanTxPduId","Pdu Handle Id","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
      /* [$CAN 1033] */
      ADD_EVENT_HANDLER(CanControllerDevice::RxEvent);
        events.Add("Rx",  "Returns the last received frame", "Poll,Raise").
          Out("Source", "Raised from an action or API", "None|Network|Action").
          Out("Hrh","Receive object handle","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
      ADD_EVENT_HANDLER(CanControllerDevice::ErrorStateEvent); /* [$CAN 1279] */
      events.Add("errorState", "Returns the current error state of the controller", "Poll,Raise").
        Out("errorState", "Current error state of the controller", "Active|Passive|Busoff");

/* [$CAN 1314] [$CAN 1317] */
      ADD_EVENT_HANDLER(CanControllerDevice::RxErrorCounterEvent);
      events.Add("RxErrorCount", "Return the Rx error count from the the controller", "Poll,Raise").
      Out("RxErrorCount", "Rx error count from the controller", "%u");
/* [$CAN 1318] [$CAN 1321] */
      ADD_EVENT_HANDLER(CanControllerDevice::TxErrorCounterEvent);
      events.Add("TxErrorCount", "Return the Rx error count from the the controller", "Poll,Raise").
      Out("TxErrorCount", "Tx error count from the controller", "%u");

/* [$CAN 1322] [$CAN 1325] */
      ADD_EVENT_HANDLER(CanControllerDevice::ErrorEvent);
      events.Add("error", "Returns the current error of the controller", "Poll,Raise").
        Out("error", "Current error of the controller", "NoError|BitMonitoring1|BitMonitoring0|Bit|CheckAckFailed|AckDelimiter|ArbitrationLost|Overload|CheckFormFailed|CheckStuffingFailed|CheckCrcFailed|BusLock");

/* [$CAN 1326] [$CAN 1329] */
      ADD_EVENT_HANDLER(CanControllerDevice::CurrentTimeEvent);
      events.Add("CurrentTime", "Return the current time in the controller", "Poll,Raise").
      Out("seconds", "seconds  timestamp from the controller", "%u").
      Out("nanoseconds", "nanoseconds  timestamp from the controller", "%u");
/* [$CAN 1330] [$CAN 1333] */
      ADD_EVENT_HANDLER(CanControllerDevice::EnableEgressTimeStampEvent);
      events.Add("EnableEgressTimeStamp", "Returns the current state of Enable Tx time stamping", "Poll,Raise").
      Out("Hth", "Hardware Object to enable", "%u").
      Out("enable", "Enable or Disable Hardware Object", "false|true");
/* [$CAN 1334] [$CAN 1337] */
      ADD_EVENT_HANDLER(CanControllerDevice::EgressTimeStampEvent);
      events.Add("EgressTimeStamp", "Return the timestamp from a Tx frame", "Poll,Raise").
      Out("TxPduId", "PDU to time stamp", "%u").
      Out("Hth", "Hardware Object to time stamp", "%u").
      Out("seconds", "seconds timestamp from the frame", "%u").
      Out("nanoseconds", "nanoseconds timestamp from the frame", "%u");
/* [$CAN 1338] [$CAN 1341] */
      ADD_EVENT_HANDLER(CanControllerDevice::IngressTimeStampEvent);
      events.Add("IngressTimeStamp", "Return the timestamp from Rx frame", "Poll,Raise").
      Out("Hrh", "Hardware Object to time stamp", "%u").
      Out("seconds", "seconds timestamp from the frame", "%u").
      Out("nanoseconds", "nanoseconds timestamp from the frame", "%u");

    }

    //--------------------------------------------------------------------------
    vrtaErrType Parent(vrtaEvent &event) {
      VECU_LOCK();
      SetValue(event, _parent);
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _status, (sizeof(_status.state)+ strlen(_status.name) + 1)); /* [$CAN 1028] */
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType WriteEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _write, (sizeof(_write)- (CAN_MAX_DATA_LENGTH - _write._length)));  /* [$CAN 1029] */
      else
        PackData(event, _write, sizeof(_write));  /* [$CAN 1029] */

      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType TxEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _tx, (sizeof(_tx)-(CAN_MAX_DATA_LENGTH - _tx._length)));  /* [$CAN 1031] */
      else
         PackData(event, _tx, sizeof(_tx));
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType RxEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _rx, (sizeof(_rx)-(CAN_MAX_DATA_LENGTH - _rx._length))); /* [$CAN 1037] */
      else
        PackData(event, _rx, sizeof(_rx));
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType ErrorStateEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _errorState, sizeof(_errorState));  /* [$CAN 1280] */
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType RxErrorCounterEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _RxErrorCount, sizeof(_RxErrorCount));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType TxErrorCounterEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _TxErrorCount, sizeof(_TxErrorCount));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

  //------------------------------------------------------------------------------
    vrtaErrType ErrorEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _error, sizeof(_error));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType CurrentTimeEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _CurrentTime, sizeof(_CurrentTime));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType EnableEgressTimeStampEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _EnableEgressTimeStamp, sizeof(_EnableEgressTimeStamp));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType EgressTimeStampEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _EgressTimeStamp, sizeof(_EgressTimeStamp));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //------------------------------------------------------------------------------
    vrtaErrType IngressTimeStampEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _IngressTimeStamp, sizeof(_IngressTimeStamp));      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

};

//------------------------------------------------------------------------------
class CanDevice : public VirtualDevice {
  protected:
    uint32 _det_instance;
    uint32 _det_runtime_instance;
    uint32 _det_api;
    uint32 _det_error;
    uint32 _det_runtime_error;
    uint8  _can_state;
    CanControllerDevice* _Controller[1];

  public:
    CanDevice(const char *name) {
      _det_instance = 0;
      _det_runtime_instance = 0;
      _det_api = 0;
      _det_error = 0;
      _det_runtime_error = 0;
      _can_state = 0;
      RegisterAs(name);
      
      _Controller[0] = new CanControllerDevice("Can_Network_CANNODE_0", CanConf_CanController_Can_Network_CANNODE_0, 0, m_ID); /* [$CAN 1111]  */
      
    }

//------------------------------------------------------------------------------
#if (CAN_DEV_ERROR_DETECT == STD_ON)
    void ReportDETError(uint32 instanceId, uint32 apiId, uint32 errorId) {  /* [$CAN 1058] */
      _det_instance = instanceId;

      switch (apiId) {
        case CAN_INIT_API_ID:                       _det_api = 1U; break;
        case CAN_MAINFUNCTION_WRITE_API_ID:         _det_api = 2U; break;
        case CAN_INITCONTROLLER_API_ID:             _det_api = 3U; break;
        case CAN_SETCONTROLLERMODE_API_ID:          _det_api = 4U; break;
        case CAN_DISABLECONTROLLERINTERRUPTS_API_ID:_det_api = 5U; break;
        case CAN_ENABLECONTROLLERINTERRUPTS_API_ID: _det_api = 6U; break;
        case CAN_WRITE_API_ID:                      _det_api = 7U; break;
        case CAN_GETVERSIONINFO_API_ID:             _det_api = 8U; break;
        case CAN_MAINFUNCTION_READ_API_ID:          _det_api = 9U; break;
        case CAN_MAINFUNCTION_BUSOFF_API_ID:        _det_api = 10U; break;
        case CAN_MAINFUNCTION_WAKEUP_API_ID:        _det_api = 11U; break;
        case CAN_CHECKWAKEUP_API_ID:                _det_api = 12U; break;
        case CAN_MAINFUNCTION_MODE_API_ID:          _det_api = 13U; break;
        case CAN_SETBAUDRATE_API_ID:                _det_api = 14U; break;
        case CAN_DEINIT_API_ID:                     _det_api = 15U; break;
        case CAN_GETCONTROLLERMODE_API_ID:          _det_api = 16U; break;
        case CAN_GETCONTROLLERERRORSTATE_API_ID:    _det_api = 17U; break;
        case CAN_GETCONTROLLERRXERRORCOUNTER_API_ID:_det_api = 18U; break;
        case CAN_GETCONTROLLERTXERRORCOUNTER_API_ID:_det_api = 19U; break;
        case CAN_GETCURRENTTIME_API_ID:             _det_api = 20U; break;
        case CAN_ENABLEEGRESSTIMESTAMP_API_ID:      _det_api = 21U; break;
        case CAN_GETEGRESSTIMESTAMP_API_ID:         _det_api = 22U; break;
        case CAN_GETINGRESSTIMESTAMP_API_ID:        _det_api = 23U; break;
      }

      switch (errorId) {
        case CAN_E_PARAM_POINTER:       _det_error = 1U; break;
        case CAN_E_PARAM_HANDLE:        _det_error = 2U; break;
        case CAN_E_PARAM_DATA_LENGTH:   _det_error = 3U; break;
        case CAN_E_PARAM_CONTROLLER:    _det_error = 4U; break;
        case CAN_E_UNINIT:              _det_error = 5U; break;
        case CAN_E_TRANSITION:          _det_error = 6U; break;
        case CAN_E_PARAM_BAUDRATE:      _det_error = 7U; break;
        case CAN_E_INIT_FAILED:         _det_error = 8U; break;
        case CAN_E_PARAM_LPDU:          _det_error = 9U; break;
      }
      Raise(EVENT_HANDLER(CanDevice::DETEvent));
    }

    //------------------------------------------------------------------------------
    void ReportRuntimeError(uint32 instanceId, uint32 apiId, uint32 errorId) {  /* [$CAN 1414] */
      _det_runtime_instance = instanceId;

      switch (apiId) {
        case CAN_E_DATALOST:       _det_runtime_error = 1U; break;
      }
      Raise(EVENT_HANDLER(CanDevice::DETRuntimeEvent));
    }
#endif
    //--------------------------------------------------------------------------
    void RaiseCanState(Can_DriverStatus state) {
      switch (state) {
        case CAN_UNINIT: _can_state = 0U; break;
        case CAN_READY:  _can_state = 1U; break;
      }
      Raise(EVENT_HANDLER(CanDevice::StateEvent));
    }

    //--------------------------------------------------------------------------
    void RaiseIsr(void){
#ifdef OS_ISR_VECTOR_Can_IrqHandler
      RaiseInterrupt(OS_ISR_VECTOR_Can_IrqHandler);
#endif
    }

    //--------------------------------------------------------------------------
    void UpdateStateEvent(int index, Can_EventState state, const char* hardwarename) {
      _Controller[index]->RaiseStateEvent(index, state, hardwarename);
    }

    //--------------------------------------------------------------------------
    void UpdateErrorState(int index, vrtaUInt errorState) {
      _Controller[index]->RaiseErrorStateEvent(errorState);
    }

    //--------------------------------------------------------------------------
    void UpdateWriteEvent(int index, boolean source, uint8 result, Can_HwHandleType Hth, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseWriteEvent(index, source, result, Hth, frame);
    }

    //--------------------------------------------------------------------------
    void UpdateRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseRxEvent(index, handle, frame);
    }

    //--------------------------------------------------------------------------
    void UpdateTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseTxEvent(index, handle, frame);
    }

    //--------------------------------------------------------------------------
    void UpdateControllerRxErrorCounter(int index, uint8 RxErrorCount) {
      _Controller[index]->RaiseRxErrorCounterEvent(RxErrorCount);
    }

    //--------------------------------------------------------------------------
    void UpdateControllerTxErrorCounter(int index, uint8 TxErrorCount) {
      _Controller[index]->RaiseTxErrorCounterEvent(TxErrorCount);
    }

    //--------------------------------------------------------------------------
    void UpdateError(int index, vrtaUInt error) {
      _Controller[index]->RaiseErrorEvent(error);
    }

    //--------------------------------------------------------------------------
    void UpdateCurrentTime(int index, Can_TimeStampType timeStamp) {
      _Controller[index]->RaiseCurrentTimeEvent(timeStamp);
    }

    //--------------------------------------------------------------------------
    void UpdateEnableEgressTimeStamp(int index, Can_HwHandleType Hth, boolean enabled) {
      _Controller[index]->RaiseEnableEgressTimeStampEvent(Hth,enabled);
    }

    //--------------------------------------------------------------------------
    void UpdateEgressTimeStampEvent (int index,  PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType timeStamp)  {
      _Controller[index]->RaiseEgressTimeStampEvent (TxPduId, Hth, timeStamp);
    }

    //--------------------------------------------------------------------------
    void UpdateIngressTimeStamp(int index, Can_HwHandleType Hrh, Can_TimeStampType timeStamp) {
      _Controller[index]->RaiseIngressTimeStampEvent(Hrh, timeStamp);
    }

  protected:
    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the basic information about the device
    void GetDeviceInfo(OptList &info) {
      info.Add("Type", "Can");
      info.Add("Description", "Implementation of AUTOSAR Can");
      info.Add("Version", "3.0.51"); /* [$CAN 1009] */
    }

    //--------------------------------------------------------------------------
    void GetDeviceActions(ActionList &actions) {

    }

    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the event handlers and descriptions
    void GetDeviceEvents(EventList &events) {
#if (CAN_DEV_ERROR_DETECT == STD_ON)  /* [$CAN 1014] */
      /* [$CAN 1056] */
      ADD_EVENT_HANDLER(CanDevice::DETEvent);
        events.Add("DET", "DET error raised in Can", "Poll,Raise").
          Out("Instance", "The Can instance",          "%u").
          Out("API",      "The API causing the error", CAN_APIS).
          Out("Error",    "The most recent error",     CAN_DETS);
      /* [$CAN 1412] */
      ADD_EVENT_HANDLER(CanDevice::DETRuntimeEvent);
        events.Add("DETRuntime", "DET Runtime error raised in Can", "Poll,Raise").
          Out("Instance", "The Can instance",          "%u").
          Out("API",      "The API causing the error", CAN_APIS).
          Out("Error",    "The most recent error",     CAN_RUNTIME);
#endif
      /* [$CAN 1019] */
      ADD_EVENT_HANDLER(CanDevice::StateEvent);
      events.Add("State",  "Can Driver State", "Poll,Raise").
        Out("State", "Can Driver State", "Uninit|Ready");
    }

    //--------------------------------------------------------------------------
    vrtaErrType DETEvent(vrtaEvent &event) {
      SetValue(event, _det_instance, _det_api, _det_error); /* [$CAN 1057] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType DETRuntimeEvent(vrtaEvent &event) {
      SetValue(event, _det_runtime_instance, _det_api, _det_runtime_error); /* [$CAN 1413] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateEvent(vrtaEvent &event) {
      SetValue(event, _can_state); /* [$CAN 1027] */
      return RTVECUErr_NONE;
    }
};

/*******************************************************************************
 *                         Global Variables
 ******************************************************************************/
static CanDevice Can("Can"); /* [$CAN 1005] [$CAN 1020] [$CAN 1008] */

/*******************************************************************************
 *                         Interface
 ******************************************************************************/

// -----------------------------------------------------------------------------
void Can_ReportDETError(uint32 instanceId, uint32 apiId, uint32 errorId) { /* [$CAN 1058] */
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  Can.ReportDETError(instanceId, apiId, errorId);
#endif
}

// -----------------------------------------------------------------------------
void Can_ReportRuntimeError(uint32 instanceId, uint32 apiId, uint32 errorId) { /* $CAN 1414 */
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  Can.ReportRuntimeError(instanceId, apiId, errorId);
#endif
}

// -----------------------------------------------------------------------------
void Can_RaiseInterrupt(void) {
  Can.RaiseIsr();
}

//------------------------------------------------------------------------------
void Can_RaiseWriteEvent(int index, boolean source, uint8 result, Can_HwHandleType Hth, Can_Hwp_Frame* frame) {
   Can.UpdateWriteEvent(index, source, result, Hth, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
   Can.UpdateRxEvent(index, handle, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
   Can.UpdateTxEvent(index, handle, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseStateEvent(int index, Can_EventState state, const char* hardwarename) {
  Can.UpdateStateEvent(index, state, hardwarename);
}

//------------------------------------------------------------------------------
void Can_RaiseCanState(Can_DriverStatus state) {
  Can.RaiseCanState(state);
}

// -----------------------------------------------------------------------------
void Can_RaiseErrorState(int index, vrtaUInt errorState) {
  Can.UpdateErrorState(index, errorState);
}

// -----------------------------------------------------------------------------
void Can_RaiseControllerRxErrorCounterEvent(int index, uint8 RxErrorCount) {
  Can.UpdateControllerRxErrorCounter(index, RxErrorCount);
}

// -----------------------------------------------------------------------------
void Can_RaiseControllerTxErrorCounterEvent( int index, uint8 TxErrorCount) {
  Can.UpdateControllerTxErrorCounter(index, TxErrorCount);
}

//------------------------------------------------------------------------------
void Can_RaiseError(int index, vrtaUInt error) {
  Can.UpdateError(index, error);
}

// -----------------------------------------------------------------------------
void Can_RaiseCurrentTimeEvent( int index, Can_TimeStampType timeStamp) {
  Can.UpdateCurrentTime(index, timeStamp);
}

// -----------------------------------------------------------------------------
void Can_RaiseEnableEgressTimeStampEvent(int index, Can_HwHandleType Hth, boolean enabled) {
  Can.UpdateEnableEgressTimeStamp(index, Hth, enabled);
  }

// -----------------------------------------------------------------------------
void Can_RaiseEgressTimeStampEvent (int index, PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType timeStamp)  {
  Can.UpdateEgressTimeStampEvent (index, TxPduId, Hth, timeStamp);
}

// -----------------------------------------------------------------------------
void Can_RaiseIngressTimeStampEvent(int index, Can_HwHandleType Hrh, Can_TimeStampType timeStamp) {
  Can.UpdateIngressTimeStamp(index, Hrh, timeStamp);
}


