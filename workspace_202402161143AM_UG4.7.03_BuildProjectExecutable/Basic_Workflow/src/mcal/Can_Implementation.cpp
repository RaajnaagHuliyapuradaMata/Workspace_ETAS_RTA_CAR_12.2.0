/*******************************************************************************
 * Autogenerated by MCALgen for CAN V3.0.51.35438: Can_Implementation.cpp
 *******************************************************************************/
 /* [$Satisfies $CAN 1003] */
 /* [$Satisfies $CAN 1004] */

// ---------------------------------------------------------------------
// Compile Options:
//  CAN_ALLOW_STOP_FROM_SLEEP : In Can_SetControllerMode_helper
//  CAN_SYNCHRONOUS_SETCONTROLLERMODE : In Can_SetControllerMode_helper
//  CAN_RX_HWOBJ_FIFO_SIZE : In Can_RxHwObjFifoType
// ---------------------------------------------------------------------
#ifndef CAN_RX_HWOBJ_FIFO_SIZE
#define CAN_RX_HWOBJ_FIFO_SIZE 16
#endif

extern "C" {
  #include "Can.h"
  #include "Os.h"
  #include "Can_Implementation.h"
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"       /* [$CAN 393]  */
#endif
  #include "Dem.h"
  #include "EcuM_Cbk.h"  /* [$CAN 390]  */
  #include "CanIf.h"
  #include "CanIf_Cbk.h" /* [$CAN 36]  */
}
#include "virtualDevice.hpp"
#include "Can_Device.hpp"
#include "Can_HwProvider.hpp"
#include <string.h>

/*******************************************************************************
 *                         Global Variables
 ******************************************************************************/
static Can_ConfigType* Can_CurrentConfigData = ((Can_ConfigType*) NULL_PTR);
static Can_DriverStatus Can_DriverState = CAN_UNINIT;  /* [$CAN 103] [$CAN21 103] */

static Can_Hw** Can_ChannelHw;
static uint16 Can_hwobj_maxcount = 0;

static volatile bool Can_global_read_running = false;
static volatile bool Can_global_mode_running = false;
static volatile bool Can_global_wakeup_running = false;
static volatile bool Can_global_busoff_running = false;
static volatile bool Can_global_write_running = false;

class Can_ChannelStateType {
public:
  volatile bool            started;
  volatile bool            stopped;
  volatile bool            sleeping;
  volatile bool            busoff;

  volatile bool            wakeup;
  volatile bool            has_wokenup;
  volatile boolean         drop_write;
  volatile boolean         drop_receive;
  volatile uint32          disableinterruptcount;
  volatile Can_Hwp_Event   state;
  volatile bool            awaiting_completion;
  volatile Can_ErrorStateType  currentErrorState;  // Holds the error state of the controller.
  volatile Can_ErrorStateType  previousErrorState;  // Holds the error state of the controller.
  volatile uint16          active_baudrate;
  volatile uint8          errorId;
  Can_ChannelStateType(void) {
    started          = false;
    stopped          = false;
    sleeping         = false;
    busoff           = false;
    wakeup           = false;
    has_wokenup      = false;
    drop_write       = FALSE;
    drop_receive     = FALSE;
    disableinterruptcount = 0;
    state            = CAN_HWP_EVENT_STOPPED;
    currentErrorState   = CAN_ERRORSTATE_ACTIVE;
    previousErrorState  = CAN_ERRORSTATE_ACTIVE;
    awaiting_completion = false;
    active_baudrate = 0;
    errorId = 0;
  }
};

typedef uint8 Can_Fifo_Idx;

/* [$CAN 1296] [$CAN 1293] */
class Can_RxHwObjFifoType {
private:
  Can_Hwp_Frame    frames[CAN_RX_HWOBJ_FIFO_SIZE];
  volatile uint16  handles[CAN_RX_HWOBJ_FIFO_SIZE];

  Can_Fifo_Idx     nextIn;
  Can_Fifo_Idx     nextOut;
  volatile boolean full;

public:
  Can_RxHwObjFifoType() :
    nextIn(0),
    nextOut(0),
    full(false)
  {
    clear();
  }

  /* [$CAN 1294] */
  void enqueue(const Can_Hwp_Frame* frame, Can_HwHandleType handle) {
    if(full) {
      return;
    }

    VECU_LOCK();

    // Update data in queue
    frames[nextIn] = *frame;
    handles[nextIn] = handle;

    // Update queue state variables
    nextIn = (nextIn + 1) % CAN_RX_HWOBJ_FIFO_SIZE;
    full = (nextIn == nextOut);

    VECU_UNLOCK();
  }

  void dequeue(PduInfoType& destPduInfo, Can_HwType& destMailbox, uint32 controllerIndex) {
    VECU_LOCK();

    if(isEmpty()) {
      return;
    }

    // Place the frame information to be removed into the destinations passed in
    memcpy(destPduInfo.SduDataPtr, frames[nextOut].data, CAN_MAX_FRAME_LENGTH);
    destPduInfo.SduLength = frames[nextOut].length;
    destMailbox.Hoh = handles[nextOut];
    destMailbox.CanId = frames[nextOut].id;
    destMailbox.ControllerId = Can_CurrentConfigData->Controllers[controllerIndex].hwId;

    // Update queue state variables
    nextOut = (nextOut + 1) % CAN_RX_HWOBJ_FIFO_SIZE;
    full = false;

    VECU_UNLOCK();
  }

  bool isFull() const {
    return full;
  }

  bool isEmpty() const {
    return (!full && (nextIn == nextOut));
  }

  void clear() {
    full = false;
    nextIn = 0;
    nextOut = 0;

    for (Can_Fifo_Idx idx = 0; idx < CAN_RX_HWOBJ_FIFO_SIZE; idx++) {
      // Initialise all frame slots in the buffer with a default state
      frames[idx].id = 55;
      frames[idx].swPduHandle = 55;
      frames[idx].injected = false;
      frames[idx].txConfirm = false;
      frames[idx].length = 8;
      memset(&frames[idx].data, 55, 8);

      // Initialise all handles with a default value of 0
      handles[idx] = 0;
    }
  }

};

class Can_HwobjStateType {
public:
  Can_Hwp_Frame txFrame; // tx frames have a single element buffer

  volatile bool txInuse;
  volatile bool txCancel;
  volatile bool deterror;
  bool          usesPolling;

  Can_RxHwObjFifoType rxFrameFIFO;

public:
  Can_HwobjStateType(void) :
    txInuse(false),
    txCancel(false),
    deterror(false),
    usesPolling(false)
  {
    // Initialise the (single-element) transmit frame buffer with default state
    txFrame.id = 55;
    txFrame.swPduHandle = 55;
    txFrame.injected = false;
    txFrame.txConfirm = false;
    txFrame.length = 8;

    memset(&txFrame.data, 55, 8);
  }

  void reset() {
    txInuse = false;
    rxFrameFIFO.clear();
  }

};

static Can_ChannelStateType* Can_ChannelState = ((Can_ChannelStateType*) NULL_PTR);
static Can_HwobjStateType* Can_HwobjState = ((Can_HwobjStateType*) NULL_PTR);

/*******************************************************************************
*                         API Provided to Can.c
 ******************************************************************************/
extern "C" {

//-----------------------------------------------------------------------------
Std_ReturnType Can_DETError(uint32 instanceId, uint32 apiId, uint32 errorId, boolean fromAction) {
#if (CAN_DEV_ERROR_DETECT == STD_ON)  /* [$CAN 83]  [$CAN 424] */
  if (!fromAction) {
    Det_ReportError(CAN_MODULE_ID, instanceId, apiId, errorId);  /* [$CAN 27]  [$CAN 28]  [$CAN 235] [$CAN21 235] */
  }
  Can_ReportDETError(instanceId, apiId, errorId); /* [$CAN 1058] [$CAN 1013] */
#endif
  return E_NOT_OK; /* [$CAN 89] [$CAN21 89]  [$CAN 91] [$CAN21 91] */
}

//-----------------------------------------------------------------------------
Std_ReturnType Can_DETRuntimeError(uint32 instanceId, uint32 apiId, uint32 errorId, boolean fromAction) {
#if (CAN_DEV_ERROR_DETECT == STD_ON)  /* [$CAN 83]  [$CAN 424] */
  if (!fromAction) {
    Det_ReportRuntimeError(CAN_MODULE_ID, instanceId, apiId, errorId);  /* [$CAN 1265]  */
  }
#endif
  Can_ReportRuntimeError(instanceId, apiId, errorId); /* $CAN 1414 */
  return E_NOT_OK; /* [$CAN 89] [$CAN21 89]  [$CAN 91] [$CAN21 91] */
}

// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index(uint8 ctrlId) {
  for (uint32 index = 0U; index < Can_CurrentConfigData->ControllerCount; index++) {
    if (ctrlId == (Can_CurrentConfigData->Controllers[index].ControllerId)) {
      return index;
    }
  }
  return CAN_NO_CONTROLLER_INDEX;
}

// -----------------------------------------------------------------------------
uint32 Can_Check_Valid_Baudrate(uint32 ctrlIndex, uint16 baudrate, uint32 apiId) {
 const Can_ControllerConfigType* ctrl = &Can_CurrentConfigData->Controllers[ctrlIndex];
  for (uint32 baudrate_index = 0U; baudrate_index < ctrl->BaudrateConfigCount; baudrate_index++ ) {
    if(apiId == CAN_INITCONTROLLER_API_ID) {
      if (ctrl->BaudrateConfigs[baudrate_index].Baudrate == baudrate) {
        return baudrate_index;
      }
    }
    if(apiId == CAN_SETBAUDRATE_API_ID) { // AR 4.2.1 specific
      if (ctrl->BaudrateConfigs[baudrate_index].BaudrateConfigId == baudrate) {
        return baudrate_index;
      }
    }
  }
  return CAN_NO_BAUDRATE_INDEX;
}


// -----------------------------------------------------------------------------
Can_DriverStatus Can_Get_Driver_State(void) {
  return Can_DriverState;
}

// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index_From_Hth(Can_HwHandleType hth) {
  if (hth >= Can_CurrentConfigData->TxObjectIdToControllerIndexLength) {
    return CAN_NO_CONTROLLER_INDEX;
  }
  return Can_CurrentConfigData->TxObjectIdToControllerIndex[hth];
}

// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index_From_Hrh(Can_HwHandleType hrh) {
  if (hrh >= Can_CurrentConfigData->RxObjectIdToControllerIndexLength) {
    return CAN_NO_CONTROLLER_INDEX;
  }
  return Can_CurrentConfigData->RxObjectIdToControllerIndex[hrh];
}

// -----------------------------------------------------------------------------
void Can_Rxupcall(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {   /* [$CAN 59] [$CAN21 59] [$CAN 423] [$CAN21 423]*/
  Can_RaiseRxEvent(index, handle, frame); // Raise Rx Event /* [$CAN 1039] [$CAN 1050] */

  if ((Can_ChannelState[index].drop_receive) && !frame->injected) { /* [$CAN 1045]  [$CAN 1046] [$CAN 1049] */
    return;
  }

  Can_HwobjStateType& hwObj = Can_HwobjState[handle];

  const Can_Mode rxProcessMode = Can_CurrentConfigData->Controllers[index].RxProcessing;
  const bool interruptEnabled = ((rxProcessMode == CAN_INTERRUPT || (rxProcessMode == CAN_MIXED && hwObj.usesPolling == 0)) && Can_ChannelState[index].disableinterruptcount == 0);

  if(rxProcessMode == CAN_POLLING || (rxProcessMode == CAN_MIXED && hwObj.usesPolling) || interruptEnabled) {
    hwObj.rxFrameFIFO.enqueue(frame, handle);
  }

  if (!hwObj.deterror) {
#ifdef OS_ISR_VECTOR_Can_IrqHandler

    if (interruptEnabled) { /* [$CAN 202] [$CAN21 202] */
      Can_RaiseInterrupt(); /* [$CAN 33] [$CAN21 33] */
    }
#endif
  }
}

// -----------------------------------------------------------------------------
void Can_TxConfirm(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
  Can_RaiseTxEvent(index, handle, frame); // Raise Tx Event  /* [$CAN 1032] */
  VECU_LOCK();
  Can_HwobjState[handle].txFrame = *frame;
  Can_HwobjState[handle].txInuse = true;
  Can_HwobjState[handle].txCancel = false;
  VECU_UNLOCK();
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].RxProcessing == CAN_MIXED && Can_HwobjState[handle].usesPolling == 0)) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] [$CAN21 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] [$CAN21 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_TxCancel(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
  VECU_LOCK();
  Can_HwobjState[handle].txFrame = *frame;
  Can_HwobjState[handle].txCancel = true;
  Can_HwobjState[handle].txInuse = true;
  VECU_UNLOCK();
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if ((Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].RxProcessing == CAN_MIXED && Can_HwobjState[handle].usesPolling == 0)) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] [$CAN21 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] [$CAN21 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_Wakeupcall(int index, const char* hardwarename) {
  Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED; /* [$CAN 270] [$CAN21 270] */
  Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
  Can_ChannelState[index].wakeup = true;
  Can_ChannelState[index].has_wokenup = true;
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].WakeupProcessing == CAN_INTERRUPT) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] [$CAN21 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] [$CAN21 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_Busoffcall(int index, const char* hardwarename) {
  Can_ChannelState[index].state = CAN_HWP_EVENT_BUSOFF;
    Can_ChannelState[index].currentErrorState = CAN_ERRORSTATE_BUSOFF;
  Can_RaiseErrorState(index, CAN_ERRORSTATE_BUSOFF);
    Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
  Can_ChannelState[index].busoff = true;
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].BusoffProcessing == CAN_INTERRUPT) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] [$CAN21 202] [$CAN 33] [$CAN21 33] */
    Can_RaiseInterrupt(); /* [$CAN 33] [$CAN21 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
/*Can ISR calls this API and process the Main functions */
void Can_Isr_handler() {
  Can_MainFunction_BusOff_helper(TRUE);
  Can_MainFunction_Wakeup_helper(TRUE);
  Can_MainFunction_Read_helper(TRUE);
  Can_MainFunction_Write_helper(TRUE);
}

// -----------------------------------------------------------------------------
void Can_Callback(uint32 index, Can_Hwp_Event event, Can_HwHandleType handle, Can_Hwp_Frame* frame) {

  if (Can_CurrentConfigData == NULL_PTR) {
    return;
  }
  if (index >= Can_CurrentConfigData->ControllerCount) {
    return;
  }
  const char* hardwarename = Can_ChannelHw[index]->Name();
  switch(event) {
    case CAN_HWP_EVENT_RUNNING:
      Can_ChannelState[index].state = event;
      Can_RaiseStateEvent(index, CAN_STATE_STARTED, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].started = true;
      break;

    case CAN_HWP_EVENT_SLEEPING:
      Can_ChannelState[index].state = event;
      Can_RaiseStateEvent(index, CAN_STATE_SLEEP, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].sleeping = true;
      break;

    case CAN_HWP_EVENT_STOPPED:
      Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].stopped = true;
      break;

    case CAN_HWP_EVENT_WAKEUP:
      Can_Wakeupcall(index, hardwarename);
      break;

    case CAN_HWP_EVENT_BUSOFF:
      Can_Busoffcall(index, hardwarename);
      break;

    case CAN_HWP_EVENT_RX:
      Can_Rxupcall(index, handle, frame);
      break;

    case CAN_HWP_EVENT_DATALOST:
      Can_HwobjState[index].deterror = true;
      break;

    case CAN_HWP_EVENT_TX_COMPLETED:
      Can_TxConfirm(index, handle, frame);
      break;

    case CAN_HWP_EVENT_TX_CANCELLED:
      Can_TxCancel(index, handle, frame);
      break;

    default:
      break;
  }
}

// -----------------------------------------------------------------------------
void Can_DiscardPendingInterrupts(uint32 controllerIndex) {
  // The VECU lock must be held when this function is called.
  const Can_ControllerConfigType& ctrlCfg = Can_CurrentConfigData->Controllers[controllerIndex];

  bool txOrRxInterrupts = (ctrlCfg.TxProcessing == CAN_INTERRUPT || ctrlCfg.RxProcessing == CAN_INTERRUPT);
  for (uint16 i = 0U; i < Can_hwobj_maxcount; i++) {
    if(Can_Get_Controller_Index_From_Hth(i) == controllerIndex && txOrRxInterrupts) {
      Can_HwobjState[i].reset();
    }
  }

  bool busOffInterrupts = (ctrlCfg.BusoffProcessing == CAN_INTERRUPT);
  if (busOffInterrupts) {
    Can_ChannelState[controllerIndex].busoff = false;
  }

  bool wakeupInterrupts = (ctrlCfg.WakeupProcessing == CAN_INTERRUPT);
  if (wakeupInterrupts) {
    Can_ChannelState[controllerIndex].wakeup = false;
  }
}

// -----------------------------------------------------------------------------
void SetBaudrateParameters(uint32& controller_index, uint32& baudrate_index){

  Can_Hwp_BaudrateConfig canHwpBaudrateConfig;
  const Can_ControllerBaudrateConfigType *baudrateConfig;
  baudrateConfig = &Can_CurrentConfigData->Controllers[controller_index].BaudrateConfigs[baudrate_index];
  canHwpBaudrateConfig.baudrate = baudrateConfig->Baudrate; /* [$CAN 384] [$CAN21 384] */
  canHwpBaudrateConfig.phaseSegment1 = baudrateConfig->Seg1;
  canHwpBaudrateConfig.phaseSegment2 = baudrateConfig->Seg2;
  canHwpBaudrateConfig.propagationDelay = baudrateConfig->PropSeg;
  canHwpBaudrateConfig.syncJumpWidth = baudrateConfig->SyncJumpWidth;
    Can_HwpFdbaudrateConfig fdBaudrateConfig;
    canHwpBaudrateConfig.fdBaudrateConfig = &fdBaudrateConfig;
    canHwpBaudrateConfig.fdBaudrateConfig->baudrate = 0;
    if(baudrateConfig->FdBaudrateConfig != NULL_PTR) {
      canHwpBaudrateConfig.fdBaudrateConfig->baudrate = baudrateConfig->FdBaudrateConfig->BaudRate;
      canHwpBaudrateConfig.fdBaudrateConfig->txBitRateSwitch = baudrateConfig->FdBaudrateConfig->TxBitRateSwitch;
      canHwpBaudrateConfig.fdBaudrateConfig->phaseSegment1 = baudrateConfig->FdBaudrateConfig->Seg1;
      canHwpBaudrateConfig.fdBaudrateConfig->phaseSegment2 = baudrateConfig->FdBaudrateConfig->Seg2;
      canHwpBaudrateConfig.fdBaudrateConfig->propagationDelay = baudrateConfig->FdBaudrateConfig->PropSeg;
      canHwpBaudrateConfig.fdBaudrateConfig->syncJumpWidth = baudrateConfig->FdBaudrateConfig->SyncJumpWidth;
      canHwpBaudrateConfig.fdBaudrateConfig->trcvDelayCompensationOffset = baudrateConfig->FdBaudrateConfig->TrcvDelayCompensationOffset;
      canHwpBaudrateConfig.fdBaudrateConfig->sspOffset = baudrateConfig->FdBaudrateConfig->SspOffset;
    }
  Can_ChannelState[controller_index].active_baudrate = baudrate_index;
  Can_ChannelHw[controller_index]->SetBaudrate(&canHwpBaudrateConfig);
}

// -----------------------------------------------------------------------------
// Initializes all the Can Controllers
void Can_Init_helper(const Can_ConfigType* configData) { /* [$CAN 250] [$CAN21 250] */
  uint32 index = 0;

  if (Can_Get_Driver_State() != CAN_UNINIT) {
    Can_DETError(0U, CAN_INIT_API_ID, CAN_E_TRANSITION, FALSE); /* [$CAN 174] [$CAN21 174] */
    return;  /* [$CAN 91] [$CAN21 91] */
  }
  if (configData != &Can_ConfigData && configData != CAN_DEFAULT_CONFIG) {
    Can_DETError(0U, CAN_INIT_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 175]  */
    return;  /* [$CAN 91] [$CAN21 91] */
  }

  Can_CurrentConfigData = &Can_ConfigData; /* [$CAN 245] [$CAN21 245] */

  Can_ChannelHw = new Can_Hw*[Can_CurrentConfigData->ControllerCount];
  Can_ChannelState = new Can_ChannelStateType[Can_CurrentConfigData->ControllerCount];

  if (Can_CurrentConfigData->RxObjectIdToControllerIndexLength > Can_CurrentConfigData->TxObjectIdToControllerIndexLength){
    Can_hwobj_maxcount = Can_CurrentConfigData->RxObjectIdToControllerIndexLength + 1;
  } else {
    Can_hwobj_maxcount = Can_CurrentConfigData->TxObjectIdToControllerIndexLength + 1;
  }

  Can_HwobjState = new Can_HwobjStateType[Can_hwobj_maxcount];
    for(index = 0U; index < Can_hwobj_maxcount; index++){
    Can_HwobjState[index].usesPolling = Can_CurrentConfigData->Can_HwObjUsesPolling[index];
  }
  
  for(index = 0U; index < Can_CurrentConfigData->ControllerCount; index++){
    Can_ChannelHw[index] = Can_GetHw(Can_Callback,
                               index,
                               Can_CurrentConfigData->Controllers[index].providerId,
                               Can_CurrentConfigData->Controllers[index].hwId,
                               Can_CurrentConfigData->Controllers[index].fallbackProviderId,
                               Can_CurrentConfigData->Controllers[index].fallbackHwId);

    Can_ChannelHw[index]->Configure(Can_CurrentConfigData->Controllers[index].HwpConfig);
    Can_RaiseStateEvent(index, CAN_STATE_STOPPED, Can_ChannelHw[index]->Name());  /* [$CAN 1023] [$CAN 259] [$CAN21 259] */

    /* Set default baudrate for controller */
    uint32  baudrate_index =  Can_CurrentConfigData->Controllers[index].DefaultBaudrateRefId;
    SetBaudrateParameters(index, baudrate_index);
  }

  Can_DriverState = CAN_READY; /* [$CAN 246] [$CAN21 246] */
  Can_RaiseCanState(Can_DriverState);  /* [$CAN 1021] */
}

// -----------------------------------------------------------------------------
/* [$CAN 1010] */
void Can_InitController_helper(uint8 controller, const Can_ControllerBaudrateConfigType* config) {
  if (config == NULL_PTR) {
    Can_DETError(0U, CAN_INITCONTROLLER_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 1103] */
    return; /* [$CAN 91] [$CAN21 91] */
  }
  Can_ChangeBaudrate_helper(controller, config->Baudrate, CAN_INITCONTROLLER_API_ID); /* [$CAN 1107] */
}

// -----------------------------------------------------------------------------
/* Deinitialises CAN module and controllers */
void Can_DeInit_helper(void) {
  uint32 index;
  if (Can_DriverState == CAN_READY)  {  // check module is not in state uninit  [$CAN 1255] [$CAN21 91011]
    for(index = 0; index < Can_CurrentConfigData->ControllerCount; index++){  // check controllers are not in state started [$CAN 1256] [$CAN21 91012]
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_RUNNING){
        Can_DETError(0U, CAN_DEINIT_API_ID, CAN_E_TRANSITION, FALSE);
        return;
      }
    }

    // change controllers to state uninit [$CAN 1237] [$CAN21 91010]
    Can_ChannelHw[0]->DeInit();

    Can_DriverState = CAN_UNINIT;  // change module to state uninit [$CAN 1236] [$CAN21 91009]
    for(uint32 index = 0U; index < Can_CurrentConfigData->ControllerCount; index++) {   // raise controller state change to virtual interface
      Can_RaiseStateEvent(index, CAN_STATE_UNINIT, Can_ChannelHw[index]->Name());
    }

    Can_RaiseCanState(Can_DriverState);  // [$CAN 1021] raise module state change to virtual interface.

    // delete dynamically allocated memory initialised in Can_Initp
    delete [] Can_ChannelHw;
    delete [] Can_ChannelState;
    delete [] Can_HwobjState;

    return;
  }
  else {
    Can_DETError(0U, CAN_DEINIT_API_ID, CAN_E_TRANSITION, FALSE);
    return;
  }
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_GetControllerErrorState_helper(uint8 Controller, Can_ErrorStateType* ErrorStatePtr)  {
  if (Can_DriverState == CAN_UNINIT) {
    return Can_DETError(0, CAN_GETCONTROLLERERRORSTATE_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 1261] [$CAN21 91005] */
  }
  uint32 ctrl = Can_Get_Controller_Index(Controller);
  if (ctrl == CAN_NO_CONTROLLER_INDEX) {
    return Can_DETError(0, CAN_GETCONTROLLERERRORSTATE_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 1262] [$CAN21 91006] */
  }
  if (ErrorStatePtr == NULL_PTR) {
    return Can_DETError(0, CAN_GETCONTROLLERERRORSTATE_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 1263] [$CAN21 91007] */
  }

  *ErrorStatePtr = Can_ChannelState[ctrl].currentErrorState; /* [$CAN 1264] [$CAN21 91008] */
  return E_OK;
}

// -----------------------------------------------------------------------------
/* obtains the current mode of a controller */
Std_ReturnType Can_GetControllerMode_helper(uint8 Controller, Can_ControllerStateType* ControllerModePtr) {
  if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1258] [$CAN21 91016] */
    return Can_DETError(0U, CAN_GETCONTROLLERMODE_API_ID, CAN_E_UNINIT, FALSE);
  }
  uint32 ctrl = Can_Get_Controller_Index(Controller);
  if (ctrl == CAN_NO_CONTROLLER_INDEX) {  /* [$CAN 1260] [$CAN21 91018] */
    return Can_DETError(0U, CAN_GETCONTROLLERMODE_API_ID, CAN_E_PARAM_CONTROLLER, FALSE);
  }
  if (ControllerModePtr == NULL_PTR) {  /* [$CAN 1259] [$CAN21 91017] */
    return Can_DETError(0U, CAN_GETCONTROLLERMODE_API_ID, CAN_E_PARAM_POINTER, FALSE);
  }

  switch(Can_ChannelState[ctrl].state){ /* [$CAN 1257] [$CAN21 91015] */
    case CAN_HWP_EVENT_BUSOFF:
    case CAN_HWP_EVENT_STOPPED:
      *ControllerModePtr = CAN_CS_STOPPED;
      break;
    case CAN_HWP_EVENT_RUNNING:
      *ControllerModePtr = CAN_CS_STARTED;
      break;
    case CAN_HWP_EVENT_SLEEPING:
      *ControllerModePtr = CAN_CS_SLEEP;
      break;
    default:
      return E_NOT_OK;
  }
  return E_OK;
}

  // -----------------------------------------------------------------------------
  Std_ReturnType Can_GetControllerRxErrorCounter_helper(uint8 ControllerId, uint8* RxErrorCounterPtr) {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1372] [$CAN21 512] */
      return Can_DETError(0U, CAN_GETCONTROLLERRXERRORCOUNTER_API_ID, CAN_E_UNINIT, FALSE);
    }
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {  /* [$CAN 1373] [$CAN21 513] */
      return Can_DETError(0U, CAN_GETCONTROLLERRXERRORCOUNTER_API_ID, CAN_E_PARAM_CONTROLLER, FALSE);
    }
    if (RxErrorCounterPtr == NULL_PTR) {  /* [$CAN 1374] [$CAN21 514] */
      return Can_DETError(0U, CAN_GETCONTROLLERRXERRORCOUNTER_API_ID, CAN_E_PARAM_POINTER, FALSE);
    }
    return Can_ChannelHw[ctrl]->GetControllerRxErrorCounter(RxErrorCounterPtr);  /* [$CAN 1375] [$CAN21 515] */
  }

  // -----------------------------------------------------------------------------
  void Can_InjectControllerRxErrorCount(uint8 ControllerId, uint8 RxErrorCount) {
    uint8 ErrorCount;
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    Can_ChannelHw[ctrl]->InjectControllerRxErrorCount(RxErrorCount);
    if(E_OK == Can_ChannelHw[ctrl]->GetControllerRxErrorCounter(&ErrorCount)){
      Can_RaiseControllerRxErrorCounterEvent(ctrl, ErrorCount);
    }
  }
  
  // -----------------------------------------------------------------------------
  Std_ReturnType Can_GetControllerTxErrorCounter_helper ( uint8 ControllerId, uint8* TxErrorCounterPtr ) {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1377] [$CAN21 517] */
      return Can_DETError(0U, CAN_GETCONTROLLERTXERRORCOUNTER_API_ID, CAN_E_UNINIT, FALSE);
    }
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {  /* [$CAN 1378] [$CAN21 518] */
      return Can_DETError(0U, CAN_GETCONTROLLERTXERRORCOUNTER_API_ID, CAN_E_PARAM_CONTROLLER, FALSE);
    }
    if (TxErrorCounterPtr == NULL_PTR) {  /* [$CAN 1379] [$CAN21 519] */
      return Can_DETError(0U, CAN_GETCONTROLLERTXERRORCOUNTER_API_ID, CAN_E_PARAM_POINTER, FALSE);
    }
    return Can_ChannelHw[ctrl]->GetControllerTxErrorCounter(TxErrorCounterPtr);  /* [$CAN 1380] [$CAN21 520] */
  }

  // -----------------------------------------------------------------------------
  void Can_InjectControllerTxErrorCount(uint8 ControllerId, uint8 TxErrorCount) {
    uint8 ErrorCount;
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    Can_ChannelHw[ctrl]->InjectControllerTxErrorCount(TxErrorCount);
    if(E_OK == Can_ChannelHw[ctrl]->GetControllerTxErrorCounter(&ErrorCount)){
      Can_RaiseControllerTxErrorCounterEvent(ctrl, ErrorCount);
    }
  }

  // -----------------------------------------------------------------------------
  Std_ReturnType Can_GetCurrentTime_helper ( uint8 ControllerId, Can_TimeStampType* timeStampPtr) {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1382] [$CAN21 521] */
      return Can_DETError(0U, CAN_GETCURRENTTIME_API_ID, CAN_E_UNINIT, FALSE);
    }
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {  /* [$CAN 1383] [$CAN21 522] */
      return Can_DETError(0U, CAN_GETCURRENTTIME_API_ID, CAN_E_PARAM_CONTROLLER, FALSE);
    }
    if (timeStampPtr == NULL_PTR) {  /* [$CAN 1384] [$CAN21 523] */
      return Can_DETError(0U, CAN_GETCURRENTTIME_API_ID, CAN_E_PARAM_POINTER, FALSE);
    }

    if (E_OK == Can_ChannelHw[ctrl]->ReadCurrentTime(timeStampPtr, false)) {
      Can_RaiseCurrentTimeEvent(ctrl, *timeStampPtr);
      return E_OK ;
    }
    return E_NOT_OK ;
  }

  // -----------------------------------------------------------------------------
  void Can_InjectCurrentTime(uint8 ControllerId, Can_TimeStampType timeStamp) {
    Can_TimeStampType time = {0};
    uint32 ctrl = Can_Get_Controller_Index(ControllerId);
    if (ctrl == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    if(E_OK == Can_ChannelHw[ctrl]->InjectCurrentTime(timeStamp)) { 
      if(E_OK == Can_ChannelHw[ctrl]->ReadCurrentTime(&time, true)){
        Can_RaiseCurrentTimeEvent(ctrl, time);
      }
    }
  }

  // -----------------------------------------------------------------------------
  Std_ReturnType Can_EnableEgressTimeStamp_helper(Can_HwHandleType Hth) {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1387] [$CAN 1390] [$CAN21 525] [$CAN21 528] */
      return Can_DETError(0U, CAN_ENABLEEGRESSTIMESTAMP_API_ID, CAN_E_UNINIT, FALSE);
    }
    uint32 index = Can_Get_Controller_Index_From_Hth(Hth);
    if (index == CAN_NO_CONTROLLER_INDEX) {  /* [$CAN 1388] [$CAN 1386] [$CAN21 526] */
      return Can_DETError(0U, CAN_ENABLEEGRESSTIMESTAMP_API_ID, CAN_E_PARAM_HANDLE, FALSE);
    }

    if(E_OK == Can_ChannelHw[index]->EnableEgressTimeStamp(Hth)) {
      Can_RaiseEnableEgressTimeStampEvent(index, Hth, true);
      return E_OK ;
    }
    return E_NOT_OK ;
  }

  // -----------------------------------------------------------------------------
  void Can_InjectEnableEgressTimeStamp(Can_HwHandleType Hth, boolean enabled) {
    uint32 index = Can_Get_Controller_Index_From_Hth(Hth);
    if (index == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    if(E_OK == Can_ChannelHw[index]->InjectEnableEgressTimeStamp(Hth, enabled)) {  
      Can_RaiseEnableEgressTimeStampEvent(index, Hth, enabled);
    }
  }

  // -----------------------------------------------------------------------------
  Std_ReturnType Can_GetEgressTimeStamp_helper ( PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType* timeStampPtr)  {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1392] [$CAN 1397] [$CAN21 529] [$CAN21 534] */
      return Can_DETError(0U, CAN_GETEGRESSTIMESTAMP_API_ID, CAN_E_UNINIT, FALSE);
    }
    if (TxPduId >= PDUIDMAX) {  /* [$CAN 1393] [$CAN21 530] */
      return Can_DETError(0U, CAN_GETEGRESSTIMESTAMP_API_ID, CAN_E_PARAM_LPDU, FALSE);
    }
    uint32 index = Can_Get_Controller_Index_From_Hth(Hth);
    if (index == CAN_NO_CONTROLLER_INDEX) { /* [$CAN 1394] [$CAN21 531] */
      return Can_DETError(0U, CAN_GETEGRESSTIMESTAMP_API_ID, CAN_E_PARAM_HANDLE, FALSE);
    }
    if (timeStampPtr == NULL_PTR) {  /* [$CAN 1395] [$CAN21 532] */
      return Can_DETError(0U, CAN_GETEGRESSTIMESTAMP_API_ID, CAN_E_PARAM_POINTER, FALSE);
    }

    if(E_OK == Can_ChannelHw[index]->GetEgressTimeStamp(TxPduId, Hth, timeStampPtr)) {
        Can_RaiseEgressTimeStampEvent(index, TxPduId, Hth, *timeStampPtr);
      return E_OK ;
    }
    return E_NOT_OK ;
  }

  // -----------------------------------------------------------------------------
  void Can_InjectEgressTimeStamp(PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType timeStamp) {
    Can_TimeStampType time ={0};
    if (TxPduId >= PDUIDMAX) {
      return;
    }
    uint32 index = Can_Get_Controller_Index_From_Hth(Hth);
    if (index == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    if(E_OK == Can_ChannelHw[index]->InjectEgressTimeStamp(TxPduId, Hth, timeStamp)) {       if(E_OK == Can_ChannelHw[index]->GetEgressTimeStamp(TxPduId, Hth, &time)){
        Can_RaiseEgressTimeStampEvent(index, TxPduId, Hth, time);
      }
    }
  }

  // -----------------------------------------------------------------------------
  Std_ReturnType Can_GetIngressTimeStamp_helper ( Can_HwHandleType Hrh, Can_TimeStampType* timeStampPtr ) {
    if (Can_DriverState == CAN_UNINIT) {  /* [$CAN 1399]  [$CAN 1403] [$CAN21 535] [$CAN21 539] */
      return Can_DETError(0U, CAN_GETINGRESSTIMESTAMP_API_ID, CAN_E_UNINIT, FALSE);
    }
    uint32 index = Can_Get_Controller_Index_From_Hrh(Hrh);
    if (index == CAN_NO_CONTROLLER_INDEX) { /* [$CAN 1400] [$CAN21 536] */
      return Can_DETError(0U, CAN_GETINGRESSTIMESTAMP_API_ID, CAN_E_PARAM_HANDLE, FALSE);
    }
    if (timeStampPtr == NULL_PTR) {  /* [$CAN 1401] [$CAN21 537] */
      return Can_DETError(0U, CAN_GETINGRESSTIMESTAMP_API_ID, CAN_E_PARAM_POINTER, FALSE);
    }
    if(E_OK == Can_ChannelHw[index]->GetIngressTimeStamp(Hrh, timeStampPtr)) {
        Can_RaiseIngressTimeStampEvent(index, Hrh, *timeStampPtr);
      return E_OK ;
    }
    return E_NOT_OK ;
  }

  // -----------------------------------------------------------------------------
  void Can_InjectIngressTimeStamp(Can_HwHandleType Hrh, Can_TimeStampType timeStamp) {
    Can_TimeStampType time;
    uint32 index = Can_Get_Controller_Index_From_Hrh(Hrh);
    if (index == CAN_NO_CONTROLLER_INDEX) {
      return;
    }
    if(E_OK == Can_ChannelHw[index]->InjectIngressTimeStamp(Hrh, timeStamp)) { 
      if(E_OK == Can_ChannelHw[index]->GetIngressTimeStamp(Hrh, &time)){
        Can_RaiseIngressTimeStampEvent(index, Hrh, time);
      }
    }
  }

// -----------------------------------------------------------------------------
// Returns the version information
void Can_GetVersionInfo_helper(Std_VersionInfoType* versionInfo) {
  if (versionInfo == NULL_PTR) {
    Can_DETError(0U, CAN_GETVERSIONINFO_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 177] [$CAN21 177] */
    return; /* [$CAN 91] [$CAN21 91] */
  }
  /* [$CAN 105]  */
  versionInfo->vendorID = CAN_VENDOR_ID;
  versionInfo->moduleID = CAN_MODULE_ID;
  versionInfo->sw_major_version = CAN_SW_MAJOR_VERSION;
  versionInfo->sw_minor_version = CAN_SW_MINOR_VERSION;
  versionInfo->sw_patch_version = CAN_SW_PATCH_VERSION;
}
// -----------------------------------------------------------------------------
/* [$CAN 1011] */
Std_ReturnType Can_ChangeBaudrate_helper (uint8 controller, const uint16 baudrate, uint32 apiId) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    return Can_DETError(0U, apiId, CAN_E_UNINIT, FALSE); /* [$CAN 450]  [$CAN 1104] [$CAN 91] [$CAN21 91] [$CAN 1131] [$CAN21 492] */
  }

  uint32 controller_index =  Can_Get_Controller_Index(controller);
  if (controller_index == CAN_NO_CONTROLLER_INDEX) {
    return Can_DETError(0U, apiId, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 452]  [$CAN 1105] [$CAN 91] [$CAN21 91] [$CAN 1133] [$CAN21 494] */
  }

  uint32 baudrate_index = Can_Check_Valid_Baudrate(controller_index, baudrate, apiId);

  if (baudrate_index == CAN_NO_BAUDRATE_INDEX) {
    return Can_DETError(0U, apiId, CAN_E_PARAM_BAUDRATE, FALSE); /* [$CAN 451]  [$CAN 91] [$CAN21 91] [$CAN 1132] [$CAN21 493] */
  }

  if (Can_ChannelState[controller_index].state != CAN_HWP_EVENT_STOPPED) {
    return Can_DETError(0U, apiId, CAN_E_TRANSITION, FALSE); /* [$CAN 453]  [$CAN 1106] [$CAN 91] [$CAN21 91] [$CAN 260] [$CAN21 260] [$CAN 422] [$CAN21 422] */
  }

  SetBaudrateParameters(controller_index, baudrate_index);
  return E_OK;
}



// -----------------------------------------------------------------------------
// [$CAN 230] [$CAN21 230]
Std_ReturnType Can_SetControllerMode_helper(uint8 controller, Can_ControllerStateType transition, boolean fromAction) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_UNINIT, fromAction); /* [$CAN 198] [$CAN21 198] */
    return E_NOT_OK;  /* [$CAN 91] [$CAN21 91] */
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_PARAM_CONTROLLER, fromAction); /* [$CAN 199] [$CAN21 199] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }
  // If Can has been stopped by ForceBusOff then we should not start the controller again.
  if (Can_ChannelState[index].state == CAN_HWP_EVENT_BUSOFF) {
    return E_NOT_OK;
  }
  /* [$CAN 17] [$CAN21 17] */
  switch(transition) {
    case CAN_CS_STARTED:
      /* [$CAN 261] [$CAN21 261] */
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Start();
        Can_ChannelState[index].state = CAN_HWP_EVENT_RUNNING;
      } else {
        Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 409] [$CAN21 409] [$CAN 200] [$CAN21 200] */
        return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
      }
      break;

    case CAN_CS_STOPPED:
      /* [$CAN 263] [$CAN21 263] */
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        if (!Can_ChannelState[index].awaiting_completion) {
          CanIf_ControllerModeIndication(controller, CAN_CS_STOPPED);
        }
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_SLEEPING) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Stop();
        Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_RUNNING) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Stop();
        Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      } else {
        Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 410]  [$CAN 200] [$CAN21 200] */
        return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
      }
      break;

    case CAN_CS_SLEEP:
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_SLEEPING) {
        if (!Can_ChannelState[index].awaiting_completion) {
            CanIf_ControllerModeIndication(controller, CAN_CS_SLEEP);
        }
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelState[index].has_wokenup = false; /* [$CAN 361] [$CAN21 361] Clear the wakeup flag before going to SLEEP. */
        Can_ChannelState[index].state = CAN_HWP_EVENT_SLEEPING;  /* [$CAN 265] [$CAN21 265] */
        Can_ChannelHw[index]->Sleep();  /* [$CAN 257] [$CAN21 257] */
      } else {
         Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 411] [$CAN21 411] [$CAN 200] [$CAN21 200] */
         return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
      }
      break;
        default:
      Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 200] [$CAN21 200] */
      return E_OK; /* [$CAN 91] [$CAN21 91] */
  }

#ifdef CAN_SYNCHRONOUS_SETCONTROLLERMODE /* Compile option */
  while (Can_ChannelState[index].awaiting_completion) {
    Can_MainFunction_Mode_helper();
    vrtaYield(0);
  }
#endif

  return E_OK;
}

// -----------------------------------------------------------------------------
void Can_DisableControllerInterrupts_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_DETError(0U, CAN_DISABLECONTROLLERINTERRUPTS_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 205] [$CAN21 205] */
     return; /* [$CAN 91] [$CAN21 91] */
  }

  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     Can_DETError(0U, CAN_DISABLECONTROLLERINTERRUPTS_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 206] [$CAN21 206] */
     return;
  }

  VECU_LOCK();
  Can_ChannelState[index].disableinterruptcount  += 1;  /* [$CAN 202] [$CAN21 202] [$CAN 49] [$CAN21 49] */
  VECU_UNLOCK();
}

// -----------------------------------------------------------------------------
void Can_EnableControllerInterrupts_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_ENABLECONTROLLERINTERRUPTS_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 209] [$CAN21 209] */
    return; /* [$CAN 91] [$CAN21 91] */
  }
  uint32 index =  Can_Get_Controller_Index(controller);

  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_ENABLECONTROLLERINTERRUPTS_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 210] [$CAN21 210] */
    return;
  }

  if (Can_ChannelState[index].disableinterruptcount != 0) { /* [$CAN 208] [$CAN21 208] */
    VECU_LOCK();
    Can_ChannelState[index].disableinterruptcount  -= 1; /* [$CAN 202] [$CAN21 202] [$CAN 50] [$CAN21 50] */

    // If interrupts are now enabled we want to discard any pending events that
    // would result in a notification to CanIf. This is to avoid the following sort
    // of race: interrupts are disabled and a frame is received, interrupts are
    // enabled, a frame is transmitted, the received frame is indicated to
    // CanIf by the transmit complete interrupt processing.
    if (Can_ChannelState[index].disableinterruptcount == 0) {
      Can_DiscardPendingInterrupts(index);
    }
    VECU_UNLOCK();
  }
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_CheckWakeup_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_CHECKWAKEUP_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 362] [$CAN21 362] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }

  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_CHECKWAKEUP_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 363] [$CAN21 363] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }
  if(Can_ChannelState[index].has_wokenup) {
#if (CAN_WAKEUP_SUPPORT == STD_ON)
    EcuM_SetWakeupEvent(Can_CurrentConfigData->Controllers[index].EcuMwakeupSourceId);
#endif
    return E_OK; /* [$CAN 361] [$CAN21 361] */
  }
  return E_NOT_OK;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Write_helper(Can_HwHandleType hth, const Can_PduType* pduInfo, boolean txConfirmFlag, boolean fromAction) {
  Std_ReturnType ret;

  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_UNINIT, fromAction); /* [$CAN 216] [$CAN21 216] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }

  uint32 index = Can_Get_Controller_Index_From_Hth(hth);
    if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_HANDLE, fromAction); /* [$CAN 217] [$CAN21 217] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
    }

  // if the controller has been put into state busoff or (from AR4.3.1) passive then the controller must not transmit to the network.
  if (Can_ChannelState[index].currentErrorState == CAN_ERRORSTATE_PASSIVE) {
    return E_OK;
  }

  if (pduInfo == NULL_PTR) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_POINTER, fromAction); /* [$CAN 219] [$CAN21 219] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }

  if (pduInfo->sdu == NULL_PTR) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_POINTER, fromAction); /* [$CAN 219] [$CAN21 219] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }

  const Can_ControllerBaudrateConfigType *baudrateConfig;
  uint16 baudrate_index = Can_ChannelState[index].active_baudrate;
  baudrateConfig = &Can_CurrentConfigData->Controllers[index].BaudrateConfigs[baudrate_index];

  if ((pduInfo->length > CAN_MAX_DATA_LENGTH) ||
      ((pduInfo->length > CAN_STD_DATA_LENGTH) && (baudrateConfig->FdBaudrateConfig == NULL_PTR)) ||
      ((pduInfo->length > CAN_STD_DATA_LENGTH) && (!CAN_ID_FD_BIT_SET(pduInfo->id)))) { /* [$CAN 1219] [$CAN21 218] [$CAN 1230] */
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_DATA_LENGTH, fromAction); /* [$CAN 218] [$CAN21 218] [$CAN 1218] [$CAN21 218] [$CAN 1219] [$CAN21 218] */
    return E_NOT_OK; /* [$CAN 91] [$CAN21 91] */
  }
  /*  [$CAN 11] [$CAN21 11] */
  Can_Hwp_Frame frame = {0};
  frame.txConfirm = txConfirmFlag;
  frame.injected = fromAction;  /* [$CAN 1035] */
  frame.swPduHandle = pduInfo->swPduHandle; /* [$CAN 276] [$CAN21 276] */
  frame.id = pduInfo->id;

  if (   CAN_ID_FD_BIT_SET(pduInfo->id)                   /* if the message is supposed to be a FD frame */
      && ( (baudrateConfig->FdBaudrateConfig == NULL_PTR) || (baudrateConfig->FdBaudrateConfig->BaudRate == 0) ) /* but there is no FD config */
      && (pduInfo->length <= CAN_STD_DATA_LENGTH)) {      /* and the data is small enough to be sent as a CAN frame then send as a CAN frame */
    frame.id = pduInfo->id & ~CAN_ID_FD_BIT;    /*[$CAN 1231] */
  }
  frame.length      = pduInfo->length;
  memcpy(frame.data, pduInfo->sdu, frame.length);

  /* [$CAN 212] [$CAN21 212] [$CAN 213] [$CAN21 213] [$CAN 215]  [$CAN 434]  [$CAN 214] [$CAN21 214] [$CAN 275] [$CAN21 275] [$CAN 59] [$CAN21 59] [$CAN 1162] [$CAN21 486] */
  if (!Can_ChannelState[index].drop_write || fromAction) { /* [$CAN 1044]  */
    ret = Can_ChannelHw[index]->Write(hth, &frame); /* [$CAN 1163] [$CAN21 502] [$CAN 1203] [$CAN21 9485] [$CAN 1229] [$CAN 1230] [$CAN 1231] [$CAN 1233] [$CAN 1234] */
    Can_RaiseWriteEvent(index, fromAction, ret, hth, &frame);  /* [$CAN 1026] [$CAN 1025] [$CAN 1036] */
  } else { /* [$CAN 1043] [$CAN 1047] [$CAN 1051] [$CAN 1048]*/
    Can_RaiseWriteEvent(index, fromAction, CAN_FRAME_DROPPED, hth, &frame); /* [$CAN 1034] [$CAN 1025] [$CAN 1036] */
    ret = E_OK;
  }
  return ret;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Write_helper (boolean fromIsr) { /* [$CAN 31] [$CAN21 31] [$CAN 7] [$CAN21 7] [$CAN 110] [$CAN21 110] */
  bool run;
  Can_Hwp_Frame  txFrame;
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
  PduInfoType     pduinfo;
#endif
  VECU_LOCK();
  if (Can_global_write_running) {
    run = false;
  } else {
    Can_global_write_running = true;
    run = true;
  }
  VECU_UNLOCK();

  if (!run) {
    return;
  }

  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_global_write_running = false;
        return; /* [$CAN 91] [$CAN21 91] */
  }

  for (int i = 0; i < Can_hwobj_maxcount; i++) {
    uint32 index = Can_Get_Controller_Index_From_Hth(i);
    if (index != CAN_NO_CONTROLLER_INDEX) {
      /* [$CAN 1278] */
      if ((fromIsr && (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_MIXED && Can_HwobjState[i].usesPolling == 0)) && Can_ChannelState[index].disableinterruptcount == 0)
         || (!fromIsr && (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_POLLING || (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_MIXED && Can_HwobjState[i].usesPolling)))) {
        if (Can_HwobjState[i].txInuse) {
          VECU_LOCK();
          txFrame = Can_HwobjState[i].txFrame;
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
          pduinfo.SduDataPtr = &txFrame.data[0];
          pduinfo.SduLength = txFrame.length;
#endif
          Can_HwobjState[i].txInuse = false;
          VECU_UNLOCK();

          if (Can_HwobjState[i].txCancel) {
            Can_HwobjState[i].txCancel = false;
            if (txFrame.txConfirm) { /* [$CAN 1113] */
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
              CanIf_CancelTxConfirmation(txFrame.swPduHandle, &pduinfo); /* [$CAN 287]   [$CAN 235] [$CAN21 235] */
#endif
            }
          } else {
            if(txFrame.txConfirm) {  /* [$CAN 1053] [$CAN 1054] */
              CanIf_TxConfirmation(txFrame.swPduHandle);// Transmit Confirmation /* [$CAN 234] [$CAN21 234] [$CAN 16] [$CAN21 16] */
            }
          }
        }
      }
    }
  }
  Can_global_write_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Read_helper(boolean fromIsr) { /* [$CAN 396] [$CAN21 396] [$CAN 108] [$CAN21 108] [$CAN 7] [$CAN21 7] */
  bool run;

  VECU_LOCK();
  if (Can_global_read_running) {
    run = false;
  } else {
    Can_global_read_running = true;
    run = true;
  }
  VECU_UNLOCK();

  if (!run) { /* [$CAN 12] [$CAN21 12] */
    return;
  }

  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_global_read_running = false;
    return; /* [$CAN 91] [$CAN21 91] */
  }

  PduInfoType pduInfo;
  Can_HwType mailbox;

  for (int i = 0; i < Can_hwobj_maxcount; i++) {
    uint32 controllerIndex = Can_Get_Controller_Index_From_Hrh(i);

    if (controllerIndex != CAN_NO_CONTROLLER_INDEX) {
      Can_HwobjStateType& hwObj = Can_HwobjState[i];

      /* [$CAN 1277] */
      const Can_Mode rxProcessMode = Can_CurrentConfigData->Controllers[controllerIndex].RxProcessing;
      const uint32 disableInterruptCount = Can_ChannelState[controllerIndex].disableinterruptcount;

      if ((fromIsr && (rxProcessMode == CAN_INTERRUPT || rxProcessMode == CAN_MIXED) && !hwObj.usesPolling && disableInterruptCount == 0)
            || (!fromIsr && (rxProcessMode != CAN_MIXED || hwObj.usesPolling))) {

        if (hwObj.deterror) {
          hwObj.deterror = false;

          Can_DETRuntimeError(0U, CAN_MAINFUNCTION_READ_API_ID, CAN_E_DATALOST, FALSE); /* [$CAN 395] [$CAN21 395] */
        }

        while (!hwObj.rxFrameFIFO.isEmpty()) {
          /* [$CAN 1295] */
          uint8 sduCopy[CAN_MAX_FRAME_LENGTH];
          pduInfo.SduDataPtr = sduCopy;
          hwObj.rxFrameFIFO.dequeue(pduInfo, mailbox, controllerIndex);

          boolean doIndication = TRUE;

          if (Can_CurrentConfigData->CanLPduReceiveCalloutFunction != NULL_PTR) {
            doIndication = Can_CurrentConfigData->CanLPduReceiveCalloutFunction(mailbox.Hoh, mailbox.CanId, pduInfo.SduLength, pduInfo.SduDataPtr); /* [$CAN 444] [$CAN21 444] [$CAN 1126] [$CAN21 501] [$CAN 1232] */
          }

          if (doIndication) {
            /* [$CAN 279] [$CAN21 279] [$CAN 234] [$CAN21 234] [$CAN 59] [$CAN21 59] [$CAN 396] [$CAN21 396] [$CAN 60] [$CAN21 60] [$CAN 1126] [$CAN21 501] [$CAN 1232] */
            CanIf_RxIndication(&mailbox, &pduInfo);
          }
        }
      }
    }
  }

  Can_global_read_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_BusOff_helper ( boolean fromIsr) { /* [$CAN 109] [$CAN21 109] [$CAN 7] [$CAN21 7] [$CAN 110] [$CAN21 110] */
  bool run;
  VECU_LOCK();

  if (Can_global_busoff_running) {
      run = false;
  }
  else {
      Can_global_busoff_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_busoff_running = false;
          return; /* [$CAN 91] [$CAN21 91] */
  }

  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if (Can_ChannelState[i].busoff) {
      Can_ChannelState[i].busoff = false;
      if((fromIsr && Can_CurrentConfigData->Controllers[i].BusoffProcessing == CAN_INTERRUPT && Can_ChannelState[i].disableinterruptcount == 0) || !fromIsr) {
         CanIf_ControllerBusOff(Can_CurrentConfigData->Controllers[i].ControllerId); /* [$CAN 234] [$CAN21 234] [$CAN 20] [$CAN21 20] */
      }
    }
  }
  Can_global_busoff_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Wakeup_helper (boolean fromIsr) /* [$CAN 112] [$CAN21 112] [$CAN 7] [$CAN21 7] [$CAN 110] [$CAN21 110] [$CAN 271] [$CAN21 271] */ {
  bool run;
  VECU_LOCK();
  if (Can_global_wakeup_running) {
      run = false;
  }
  else {
      Can_global_wakeup_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_wakeup_running = false;
          return;   /* [$CAN 91] [$CAN21 91] */
  }
  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if ((Can_ChannelState[i].wakeup)) {
      Can_ChannelState[i].wakeup = false;
      if (Can_CurrentConfigData->Controllers[i].WakeupSupport) {
        if ((fromIsr && Can_CurrentConfigData->Controllers[i].WakeupProcessing == CAN_INTERRUPT && Can_ChannelState[i].disableinterruptcount == 0) || !fromIsr) {
          if (Can_CurrentConfigData->Controllers[i].EcuMwakeupSourceId != 0) {
#if (CAN_WAKEUP_SUPPORT == STD_ON)
             EcuM_CheckWakeup(Can_CurrentConfigData->Controllers[i].EcuMwakeupSourceId); /* [$CAN 364] [$CAN21 364]  [$CAN 235] [$CAN21 235] */
#endif
          }
        }
      }
    }
  }
  Can_global_wakeup_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Mode_helper (void) { /* [$CAN 369] [$CAN21 369] [$CAN 7] [$CAN21 7] */
  bool run;
  VECU_LOCK();
  if (Can_global_mode_running) {
      run = false;
  }
  else {
      Can_global_mode_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_mode_running = false;
          return;  /* [$CAN 91] [$CAN21 91] */
  }
  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if (Can_ChannelState[i].started) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].started = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CAN_CS_STARTED);  /* [$CAN 373] [$CAN21 373] [$CAN 234] [$CAN21 234] [$CAN 1121] [$CAN21 370] */
    }
    if (Can_ChannelState[i].stopped) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].stopped = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CAN_CS_STOPPED);  /* [$CAN 1121] [$CAN21 370] */
    }
    if (Can_ChannelState[i].sleeping) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].sleeping = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CAN_CS_SLEEP);  /* [$CAN 1121] [$CAN21 370] */
    }
  }
  Can_global_mode_running = false;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Wakeup(uint8 controller) { /* [$CAN 1119] */
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  Can_ChannelHw[index]->ForceWakeup();
  return E_OK;
}

Std_ReturnType Can_injectErrorState(uint8 controller, Can_ErrorStateType errorState) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  /* [$CAN 1283] [$CAN 1284] [$CAN 1281] */
  switch(errorState){
    case CAN_ERRORSTATE_ACTIVE:
      Can_ChannelState[index].previousErrorState = Can_ChannelState[index].currentErrorState;
      Can_ChannelState[index].currentErrorState = errorState;
      Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      Can_RaiseErrorState(index, errorState);
      break;
    case CAN_ERRORSTATE_PASSIVE:
      /* [$CAN 1309] [$CAN21 91023] */
      #if (CAN_SECURITY_EVENT_REPORTING == STD_ON)
        if ((Can_ChannelState[index].previousErrorState != CAN_ERRORSTATE_PASSIVE) &&
            (Can_ChannelState[index].currentErrorState = CAN_ERRORSTATE_PASSIVE)) {
          uint8 RxErrorCounter = 0U;
          uint8 TxErrorCounter = 0U;
          Can_ChannelHw[index]->GetControllerRxErrorCounter(&RxErrorCounter);
          Can_ChannelHw[index]->GetControllerTxErrorCounter(&TxErrorCounter);
          CanIf_ControllerErrorStatePassive(index, RxErrorCounter, TxErrorCounter);
        }
      #endif
      Can_ChannelState[index].previousErrorState = Can_ChannelState[index].currentErrorState;
      Can_ChannelState[index].currentErrorState = errorState;
      Can_RaiseErrorState(index, errorState);
      break;
    case CAN_ERRORSTATE_BUSOFF:
      Can_ChannelHw[index]->ForceBusOff();
      break;
    default:
      return E_NOT_OK;
  }

  return E_OK;
}

//--------------------------------------------------------------------------
Std_ReturnType Can_injectError(uint8 ControllerId, uint8 errorId) {
//  Can_ErrorType enumErrorId;
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(ControllerId);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  Can_ChannelState[index].errorId = errorId;  Can_RaiseError(index, errorId);

  #if (CAN_SECURITY_EVENT_REPORTING == STD_ON)
    /*   First Can_ErrorType enum element                 Last Can_ErrorType enum element */
    if ((errorId >= (uint8)CAN_ERROR_BIT_MONITORING1) && (errorId <= (uint8)CAN_ERROR_BUS_LOCK)) { /* [$CAN21 91024] */
      CanIf_ErrorNotification (ControllerId, (Can_ErrorType)errorId); /* [$CAN 1308] [$CAN21 91022] [$CAN 1404] */
    }
  #endif
  return E_OK;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Buson(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  if (Can_ChannelState[index].state == CAN_HWP_EVENT_BUSOFF) {
    Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
  }

  return E_OK;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Busoff(uint8 controller) { /* [$CAN 1118] */
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  Can_ChannelHw[index]->ForceBusOff();
  return E_OK;
}


// -----------------------------------------------------------------------------
static bool Can_Channel_Is_Initialized(uint8 index) {
  if (!Can_ChannelState || !Can_CurrentConfigData) {
    return false;
  }
  return (index < Can_CurrentConfigData->ControllerCount);
}

// -----------------------------------------------------------------------------
void Can_Drop_Write_Action_helper(uint8 index, boolean dropWrite) {
  if (Can_Channel_Is_Initialized(index)) {
    Can_ChannelState[index].drop_write  = dropWrite; /* [$CAN 1043] [$CAN 1044] */
  }
}

// -----------------------------------------------------------------------------
void Can_Drop_Receive_Action_helper(uint8 index, boolean dropReceive) {
  if (Can_Channel_Is_Initialized(index)) {
    Can_ChannelState[index].drop_receive = dropReceive;  /* [$CAN 1045] [$CAN 1046] */
  }
}

// -----------------------------------------------------------------------------
void Can_Inject_Write_helper(uint8 index, Can_HwHandleType hth, const Can_PduType* pduInfo, boolean txConfirmFlag, boolean fromAction) {
  Can_Write_helper(hth, pduInfo, txConfirmFlag, fromAction);
}

// -----------------------------------------------------------------------------
void Can_Inject_Rxaction_helper(uint8 index, Can_HwHandleType handle, Can_Hwp_Frame* frame) { /* [$CAN 1055] */
  if (!Can_Channel_Is_Initialized(index)) {
    return;
  }
  if (frame == NULL_PTR) {
    return;
  }
  uint32 index_tmp = Can_Get_Controller_Index_From_Hrh(handle);
  if (index_tmp != CAN_NO_CONTROLLER_INDEX && frame->length <= CAN_MAX_DATA_LENGTH) {
    Can_Rxupcall(index, handle, frame); /* [$CAN 1040] [$CAN 1055] */
  }
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Enable_Transmit_Processing_helper(uint8 controller, boolean enable) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    return E_NOT_OK;
  }
  Can_ChannelHw[index]->EnableTransmitProcessing(enable ? true : false);

  return E_OK;
}

}

