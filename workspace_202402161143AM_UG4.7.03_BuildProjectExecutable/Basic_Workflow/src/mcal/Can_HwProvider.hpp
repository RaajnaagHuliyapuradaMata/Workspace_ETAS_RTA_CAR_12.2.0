/*******************************************************************************
 * Autogenerated by MCALgen for CAN V3.0.51.35438: Can_HwProvider.hpp
 *******************************************************************************/
#ifndef CAN_HWPROVIDER_HPP_
#define CAN_HWPROVIDER_HPP_

/****************************************************************************
 *                             Include Files.
 ****************************************************************************/
extern "C" {
  #include "Can.h"
  #include "Can_HwProviderTypes.h"
}
#include "MCalHwProviderSupport.hpp"


/****************************************************************************
 *                         Useful Macros
 ****************************************************************************/
#ifndef NULL_CPP_PTR
 #define NULL_CPP_PTR  (0)
#endif

/****************************************************************************
 *                         Provider Base Class
 ****************************************************************************/
class Can_Hw;
class Can_HwProvider : public MCAL_HwProvider {
public:
  virtual Can_Hw* GetHardware(Can_Hwp_UpCall UpCall, uint32 Context, uint32 HwId) = 0;
};


/*****************************************************************************
 *                       Base Class for Can hardware
 ****************************************************************************/
class Can_Hw {
  protected:
    const char*    m_Name;
    uint32         m_HwId;
    Can_Hwp_UpCall m_UpCall;
    uint32         m_UpCallContext;

  public:
    // Concrete instances of this class should set m_Name to something meaningful.
    Can_Hw(Can_Hwp_UpCall upCall, uint32 context) :
      m_Name("?"),
      m_HwId(0),
      m_UpCall(upCall),
      m_UpCallContext(context) {
      }

    // Default destructor just to make sure the destructor is virtual.
    virtual ~Can_Hw(void) {}

    // Get the name of the hardware for human consumption.
    const char* Name(void) { return m_Name; }

    uint32 HwId(void) { return m_HwId; }

    // Configure the CAN channel. This method will only be called once.
    virtual void Configure(const Can_Hwp_ChannelConfig* config) = 0;

    // Set the baudrate.
    virtual void SetBaudrate(const Can_Hwp_BaudrateConfig* baudrate) = 0;

    // Start transition to the started state. I.e. join the network read for transmit
    // and receive.
    virtual void Start(void) = 0;

    // Start transition to sleep state.
    virtual void Sleep(void) = 0;

    // Start transition to the stopped state.
    virtual void Stop(void) = 0;

    // Schedule a frame for transmission on the channel.
    virtual Can_ReturnType Write(Can_HwHandleType handle, Can_Hwp_Frame* frame) = 0;

    // Check if this channel caused a wakeup event.
    virtual bool CausedWakeup(void) = 0;

    // Get the current state of this channel: CAN_HWP_EVENT_RUNNING, CAN_HWP_EVENT_STOPPED or
    // CAN_HWP_EVENT_SLEEPING.
    virtual Can_Hwp_Event State(void) = 0;

    // Simulate a bus-off event.
    virtual void ForceBusOff(void) = 0;

    // Simulate a wakeup event.
    virtual void ForceWakeup(void) = 0;

    // Puts the controllers into an uninitialised state.
    virtual void DeInit(void) = 0;

    // TESTING ONLY: Enable/disable transmits from actually being put on the wire. Used for
    // testing transmit cancellation.
    virtual void EnableTransmitProcessing(bool enable) { /* Implement if needed for testing. */ };

    virtual Std_ReturnType GetControllerRxErrorCounter(uint8* RxErrorCounterPtr) = 0;
    virtual Std_ReturnType GetControllerTxErrorCounter(uint8* TxErrorCounterPtr) = 0;
    virtual void InjectControllerRxErrorCount(uint8 RxErrorCount) = 0;
    virtual void InjectControllerTxErrorCount(uint8 TxErrorCount) = 0;

    virtual Std_ReturnType EnableEgressTimeStamp(Can_HwHandleType Hth) = 0;
    virtual Std_ReturnType ReadCurrentTime(Can_TimeStampType* timeStampPtr, boolean fromAction) = 0;
    virtual Std_ReturnType GetEgressTimeStamp(PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType* timeStampPtr) = 0;
    virtual Std_ReturnType GetIngressTimeStamp(Can_HwHandleType Hrh, Can_TimeStampType* timeStampPtr) = 0;
    virtual Std_ReturnType InjectEnableEgressTimeStamp(Can_HwHandleType Hth, boolean enabled) = 0;
    virtual Std_ReturnType InjectCurrentTime(Can_TimeStampType timeStamp) = 0;
    virtual Std_ReturnType InjectEgressTimeStamp(PduIdType TxPduId, Can_HwHandleType Hth, Can_TimeStampType timeStamp) = 0;
    virtual Std_ReturnType InjectIngressTimeStamp(Can_HwHandleType Hrh, Can_TimeStampType timeStamp) = 0;
};

/************************************************************************************************************
 *                        API.
 ***********************************************************************************************************/
extern Can_HwProvider *Can_GetHwProvider(uint32 ProviderID);

extern Can_Hw         *Can_GetHw(Can_Hwp_UpCall UpCall,
                                 uint32         Context,
                                 uint32         ProviderID,
                                 uint32         HwId,
                                 uint32         FallbackProviderID,
                                 uint32         FallbackHwId);

extern bool Can_FramePassesFiltering(uint32 frameId, const Can_Hwp_RxHwObject* dest);
extern void Can_LoadRxObjFromConfig(Can_Hwp_RxHwObject* dest, const Can_Hwp_RxHwObject* config);

#endif /* CAN_HWPROVIDER_HPP_ */

