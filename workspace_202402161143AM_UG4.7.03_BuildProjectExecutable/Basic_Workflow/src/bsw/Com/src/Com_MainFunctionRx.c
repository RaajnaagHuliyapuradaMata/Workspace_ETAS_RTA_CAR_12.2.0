/*
 **********************************************************************************************************************
 *
 * COPYRIGHT (c) ETAS GmbH 2014, all rights reserved
 * The reproduction, distribution and utilization of this document as well as the communication of its contents to
 * others without explicit authorization is prohibited. Offenders will be held liable for the payment of damages.
 * All rights reserved in the event of the grant of a patent, utility model or design.
 *
 **********************************************************************************************************************
*/

/*
 **********************************************************************************************************************
 * Includes
 **********************************************************************************************************************
*/

#include "Com_Prv.h"
#include "Com_Prv_Inl.h"


/*
 **********************************************************************************************************************
 * Defines/Macros
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Prototypes
 **********************************************************************************************************************
*/
#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
LOCAL_INLINE void Com_Prv_RxTimeoutProcessing(PduIdType idRxPdu_uo, boolean rxIndication_b);
#endif

#ifdef COM_RxIPduTimeout

LOCAL_INLINE void Com_Prv_IPduBasedTimeoutMonitoring(PduIdType idRxPdu_uo, boolean reloadDmTimer_b);

LOCAL_INLINE void Com_Prv_IPduBasedSigTimeoutAction(PduIdType idRxPdu_uo);

#ifdef COM_RX_SIGNALGROUP
LOCAL_INLINE void Com_Prv_IPduBasedSigGrpTimeoutAction(PduIdType idRxPdu_uo);
#endif

#endif /* #ifdef COM_RxIPduTimeout */

#ifdef COM_RxSigUpdateTimeout
LOCAL_INLINE void Com_Prv_SigBasedTimeoutMonitoring(PduIdType idRxPdu_uo);
#endif

#ifdef COM_RxSigGrpUpdateTimeout
LOCAL_INLINE void Com_Prv_SigGrpBasedTimeoutMonitoring(PduIdType idRxPdu_uo);
#endif

#ifdef COM_RxIPduDeferredProcessing
LOCAL_INLINE void Com_Prv_ProcessDeferredRxIpdu(PduIdType idPdu_uo);
#endif

#ifdef COM_RXIPDU_TP_INVALIDATION

#ifdef COM_RxSigInvalid
LOCAL_INLINE void Com_Prv_ExecuteRxSigInvalidActions(PduIdType idPdu_uo);
#endif /* end of COM_RxSigInvalid */

#ifdef COM_RxSigGrpInvalid
LOCAL_INLINE void Com_Prv_ExecuteRxSigGrpInvalidActions(PduIdType idPdu_uo);
#endif /* end of COM_RxSigGrpInvalid */

#endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */


/*
 **********************************************************************************************************************
 * Variables
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Constants
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Functions
 **********************************************************************************************************************
*/

#define COM_START_SEC_CODE
#include "Com_MemMap.h"

/*
 **********************************************************************************************************************
 Function name    : Com_Prv_InternalMainFunctionRx
 Description      : Service to perform the processing of the AUTOSAR COM receive processing that
                    are not directly initiated by the calls from the RTE and PDU-R.
 Parameter        : idRxMainFunc_uo - Internal Rx-ComMainFunction Id
 Return value     : None
 **********************************************************************************************************************
*/
#ifdef COM_ENABLE_MAINFUNCTION_RX

void Com_Prv_InternalMainFunctionRx(Com_MainFunc_tuo idRxMainFunc_uo)
{
    /* DET is not checked for RxMainFuncId, as this is an internal Id generated by the Com */
    /* TRACE[SWS_Com_00664] A call to Com_MainFunctionRx shall simply return if the AUTOSAR COM module was not
    * previously initialized with a call to Com_Init.
    * TRACE[SWS_Com_00804] Error code(COM_E_UNINIT) is not reported,
    * if Com_MainFunctionRx service is called
    * before the AUTOSAR COM module was initialized with Com_Init or after a call to Com_DeInit */
    if (Com_InitStatus_en != COM_UNINIT)
    {
        Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
        Com_RxIpduRam_tpst          rxIpduRamPtr_pst;
        uint16_least                idxIdIpdu_qu16;
        uint16_least                numOfIpdus_qu16;
        boolean                     rxIndication_b;

        /* Get the first RxIPdu-Id to be processed for given ComMainFunction */
        idxIdIpdu_qu16 = COM_GET_MAINFUNCRX_CFG( idRxMainFunc_uo )->idFirstIpdu_uo;
        numOfIpdus_qu16 = idxIdIpdu_qu16 + COM_GET_MAINFUNCRX_CFG( idRxMainFunc_uo )->numOfIpdus_uo;

        rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idxIdIpdu_qu16);

        for ( ; idxIdIpdu_qu16 < numOfIpdus_qu16; idxIdIpdu_qu16++)
        {
            /* Check for Ipdu Group is Started/Stopped */
            if (Com_Prv_CheckRxIPduStatus((PduIdType)idxIdIpdu_qu16))
            {
                Com_Get_SchM_Enter_Com_RxIPduProcess

                rxIpduRamPtr_pst = rxIpduConstPtr_pcst->ipduRam_pst;

                /* RxIndication() status has to be stored into local variable here only,
                * so as to process its timeout later */
                rxIndication_b = Com_GetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u16);

                /* For an IPdu, check if there is any pending RxIndication to be processesed */
                if (rxIndication_b)
                {

# ifdef COM_RxIPduDeferredProcessing
                    /* For an Ipdu with Immediate Signal processing, the _INDICATION flag will be reset here */
                    if (Com_GetValue(RXIPDU,_SIGPROC,rxIpduConstPtr_pcst->rxIPduFields_u8) == COM_IMMEDIATE)
# endif
                    {
                        Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);
                    }
# ifdef COM_RxIPduDeferredProcessing
                    else
                    {
                        Com_Prv_ProcessDeferredRxIpdu((PduIdType)idxIdIpdu_qu16);
                    }
# endif /* #ifdef COM_RxIPduDeferredProcessing */

                }

# if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)

                /* Reception Deadline Monitoring */
                Com_Prv_RxTimeoutProcessing((PduIdType)idxIdIpdu_qu16, rxIndication_b);

# endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */

                Com_Get_SchM_Exit_Com_RxIPduProcess

# if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
                if (Com_GetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,rxIpduRamPtr_pst->rxFlags_u16))
                {
                    Com_SetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);

                    Com_Prv_RxToGwFifo( (Com_IpduId_tuo)idxIdIpdu_qu16 );
                }
# endif /* end of defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY) */
            }/* End of check for Ipdu Group is Started/Stopped */

            rxIpduConstPtr_pcst++;
        } /* End of for loop */
    }/* End of Com initialization status */

} /* End of Com_Prv_InternalMainFunctionRx */

#endif /*End of #ifdef COM_ENABLE_MAINFUNCTION_RX */


#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_RxTimeoutProcessing
 Description      : Performs Reception Deadline Monitoring
 Parameter        : idRxPdu_uo          - Internal Rx-IPdu Id
                    rxIndication_b      - latest RxIndication status
 Return value     : None
 **********************************************************************************************************************
*/

LOCAL_INLINE void Com_Prv_RxTimeoutProcessing(PduIdType idRxPdu_uo, boolean rxIndication_b)
{

    /* Check if deadline monitoring is enabled for Ipdu */
    if (COM_CheckRxIPduDMStatus(idRxPdu_uo))
    {
        Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;

        rxIpduConstPtr_pcst = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

#ifdef COM_RxIPduTimeout

        if (rxIpduConstPtr_pcst->timeout_u16 != COM_ZERO)
        {
            /* TRACE[SWS_Com_00290] The AUTOSAR COM module shall perform an I-PDU based
            * reception deadline monitoring for signals without an update-bit. */
            Com_Prv_IPduBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo, rxIndication_b );
        }
#endif /* #ifdef COM_RxIPduTimeout */

        /* conditionally used variable(s) is type-cast to 'void' to avoid warnings,
         * they are intentionally not placed under compiler switch statement,
         * so that these lines are always available for compilation*/
        (void)rxIndication_b;

#ifdef COM_RxSigUpdateTimeout

        /* Start timeout monitoring for signals with update-bit */
        if (rxIpduConstPtr_pcst->signalTimeoutRef_pcst != NULL_PTR)
        {
            Com_Prv_SigBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo );
        }
#endif /* #ifdef COM_RxSigUpdateTimeout */

#ifdef COM_RxSigGrpUpdateTimeout

        /* Start timeout monitoring for signal groups with update-bit */
        if (rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst != NULL_PTR)
        {
            Com_Prv_SigGrpBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo );
        }
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

    } /* End of check for reception timeout monitoring */

} /* End of Com_Prv_RxTimeoutProcessing */
#endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */


#ifdef COM_RxIPduTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedTimeoutMonitoring
 Description      : Service to perform rx-IPdus timeout processing
 Parameter        : idRxPdu_uo          - Internal Rx-IPdu Id
                    reloadDmTimer_b     - latest RxIndication status, to reload deadline timer
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_IPduBasedTimeoutMonitoring(PduIdType idRxPdu_uo, boolean reloadDmTimer_b)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxIpduRam_tpst          rxIpduRamPtr_pst;
    uint16                      rxTimeoutTicks_u16;

    rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);
    rxIpduRamPtr_pst        = rxIpduConstPtr_pcst->ipduRam_pst;

# ifdef COM_RX_DUAL_CYCLE_SUPPPORT

    /* Check if new dual-cycle-deadline is provided by application */
    if (Com_GetRamValue(RXIPDU,_RELOAD_DM_TIMER, rxIpduRamPtr_pst->rxFlags_u16))
    {
        Com_Get_SchM_Enter_Com_RxPduBuffer

        /* clear the flag to capture new till next call to MainFunctionRx */
        Com_SetRamValue(RXIPDU,_RELOAD_DM_TIMER, rxIpduRamPtr_pst->rxFlags_u16, COM_FALSE);

        Com_Get_SchM_Exit_Com_RxPduBuffer

        reloadDmTimer_b = COM_TRUE;
    }

    /* get latest dual cycle timeout. this is automic read operation, hence no locks are required. */
    rxTimeoutTicks_u16 = rxIpduRamPtr_pst->overrideTimeout_u16;

    /* check if dual cycle is not provided */
    if (rxTimeoutTicks_u16 == COM_ZERO)
# endif /* end of COM_RX_DUAL_CYCLE_SUPPPORT */
    {
        /* read timeout from calibration or the configured value */
        rxTimeoutTicks_u16 = COM_GET_RXIPDU_TIMEOUT(idRxPdu_uo, rxIpduConstPtr_pcst);
    }
    /* or else use dual-cycle timeout */

    /* Reload Ipdu timeout value on every reception or when dual-cycle deadline is updated with new value */
    if (reloadDmTimer_b)
    {
        /* FC_VariationPoint_START */
#if (COM_ENABLE_JITTERFLITER == STD_ON)
        /* CC requirements:
        * An extra cycle is added to the timeout value after a PDU has been received incase filter is
        * ON Provides a chance incase of jitter( extra cycle is added in normal case and hence
        * if JITTERFILTER is enabled extra two cycles are added)
        */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 =
                                       (rxTimeoutTicks_u16 == COM_ZERO) ? COM_RXTIMER_MAX : (rxTimeoutTicks_u16 + 2u);
#else
        /* FC_VariationPoint_END   */
        /* Extra cycle is added to prevent early timeouts */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 =
                                       (rxTimeoutTicks_u16 == COM_ZERO) ? COM_RXTIMER_MAX : (rxTimeoutTicks_u16 + 1u);
        /* FC_VariationPoint_START */
#endif /* #ifdef COM_ENABLE_JITTERFLITER */
        /* FC_VariationPoint_END   */
    }

    /* For IPduBased timeout actions, locks are already available at the individual rx-signal and signalGroup bufffers,
    * hence whole timeout monitoring(action) is not placed under locks.
    *
    * About cntrRxTimeout_u16:
    * If the control has reached this point, then IpduGroup is already started.
    * And the only other place where cntrRxTimeout_u16 is written, is
    * when Ipdugroup/DeadlineMonitoring is re-started(stopped -> started).
    * hence locks are not used even for cntrRxTimeout_u16. */

    /* If timeout is disabled for an IPdu (i.e, ComTimeOut = 0) then
    * RxTicks will be loaded with COM_RXTIMER_MAX (0xFFFF).
    * Reduce Tick Timeout only if timeout is applicable (i.e., other than COM_RXTIMER_MAX).
    *
    * Not to go less than ZERO.
    */
    if ((rxIpduRamPtr_pst->cntrRxTimeout_u16 != COM_RXTIMER_MAX) && (rxIpduRamPtr_pst->cntrRxTimeout_u16 != COM_ZERO))
    {
        --rxIpduRamPtr_pst->cntrRxTimeout_u16;
    }

    /* IPDU has timed out */
    if (rxIpduRamPtr_pst->cntrRxTimeout_u16 == COM_ZERO)
    {
        /* Reload the timer upon time out */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 = rxTimeoutTicks_u16;

        /* Perform timeout actions for Signals without update bit position */
        Com_Prv_IPduBasedSigTimeoutAction( idRxPdu_uo );

#ifdef COM_RX_SIGNALGROUP
        /* Perform timeout actions for Signal groups without update bit position */
        Com_Prv_IPduBasedSigGrpTimeoutAction( idRxPdu_uo );
#endif

#ifdef COM_RxIPduTimeoutNotify

#  if (COM_CONFIGURATION_VARIANT == COM_VARIANT_PRE_COMPILE)
        if (rxIpduConstPtr_pcst->timeoutNotification_pfct != NULL_PTR)
        {
            Com_Get_SchM_Exit_Com_RxIPduProcess

            /* The following function is generated function in com_cfg.c file
            * This function calls the timeout notification functions of IPDU, signals & signal groups
            * (without update-bit) */
            /* Notifications are invoked outside the Com locks */
            rxIpduConstPtr_pcst->timeoutNotification_pfct();

            Com_Get_SchM_Enter_Com_RxIPduProcess
        }
#  else
        Com_Get_SchM_Exit_Com_RxIPduProcess

        Com_Prv_RxIPduToutCallbacks((Com_IpduId_tuo)idRxPdu_uo);

        Com_Get_SchM_Enter_Com_RxIPduProcess
#  endif /* end of COM_CONFIGURATION_VARIANT */

#endif /* #ifdef COM_RxIPduTimeoutNotify */

    } /* if (rxIpduRamPtr_pst->cntrRxTimeout_u16 == COM_ZERO) */

} /* End of Com_Prv_IPduBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxIPduTimeout */


/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigTimeoutAction
 Description      : Service to execute rx-signal timeout action
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
#ifdef COM_RxIPduTimeout
LOCAL_INLINE void Com_Prv_IPduBasedSigTimeoutAction(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst          rxSigConstPtr_pcst;
    uint16_least                idxSig_qu16;

    rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    /* Set the signal flags to indicate timeout
    * When the signal is read using function Com_ReceiveSignal() , if signal is timed out then
    * either previous value or init value is returned based on the action configured
    */
    rxSigConstPtr_pcst = COM_GET_RXSIG_CONSTDATA(rxIpduConstPtr_pcst->idRxSig_uo);

    for (idxSig_qu16 = rxIpduConstPtr_pcst->numOfSig_u16; idxSig_qu16 != COM_ZERO; idxSig_qu16--)
    {
        /* Signal with update-bit have seperate timeout handling
        * Signals without update-bit are marked as timed out, when IPdu times out.
        */
#ifdef COM_RxSigUpdateBit
        if (Com_GetValue(GEN,_UPDBITCONF,rxSigConstPtr_pcst->general_u8) == COM_FALSE)
#endif
        {
            uint8 timeoutAction_u8;

            timeoutAction_u8 = (uint8)Com_GetValue(RXSIG,_TOACTION,rxSigConstPtr_pcst->rxSignalFields_u16);

            if (timeoutAction_u8 != COM_NONE)
            {
                Com_Get_SchM_Enter_Com_RxSigBuff(MAINFUNCTIONRX)

                /**
                * TRACE[SWS_Com_00470] If ComRxDataTimeoutAction is set to REPLACE,
                * the AUTOSAR COM module shall replace the signal's value by its ComSignalInitValue
                * when the reception deadline monitoring timer of a signal expires.
                * In case the ComSignalInitValue replaces the last received value, the last received
                * value is overwritten and gets lost. Therefore, the AUTOSAR COM module returns the
                * ComSignalInitValue for this signal until a new value is received.
                * TRACE[SWS_Com_00875] If ComRxDataTimeoutAction is set to SUBSTITUTE,
                * the AUTOSAR COM module shall replace the signal's value by its ComTimeoutSubstitutionValue
                * when the reception deadline monitoring timer of a signal expires.
                */
                (void)Com_Prv_RxReplaceSignal(rxSigConstPtr_pcst, rxIpduConstPtr_pcst->idMainFunc_uo, timeoutAction_u8);

                Com_Get_SchM_Exit_Com_RxSigBuff(MAINFUNCTIONRX)
            }
            else
            {
                /**
                * TRACE[SWS_Com_00500] If the reception deadline monitoring timer of a signal or signal group expires
                * and the configuration parameter ComRxDataTimeoutAction for this signal or signal group is either
                * omitted or configured to NONE, the AUTOSAR COM module shall not replace the signal or the signals
                * of the signal groups respectively.
                */
            }

            /* even if signal buffer is overwritten with value in timeout-action,
            notification is not required to be invoked due to the below requirement
            that mandates only for successful reception */
            /* TRACE[SWS_Com_00883] For each ComNotification that is configured for a signal or signal group,
            the AUTOSAR COM shall indicate each successful transmission/reception via the configured notifications. */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter
            * MASKED_NEW_DIFFERS_MASKED_OLD, the AUTOSAR COM module shall treat the
            * first value received for this signal after a reception deadline monitoring timeout
            * occurred for this signal the same way as if the value has passed the filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,(rxSigConstPtr_pcst->sigRAM_pst->rxSigRAMFields_u8),COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        rxSigConstPtr_pcst++;
    }

} /* End of Com_Prv_IPduBasedSigTimeoutAction */
#endif /* #ifdef COM_RxIPduTimeout */


/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigGrpTimeoutAction
 Description      : Service to execute rx-signalGroup timeout action
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
#if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout)
LOCAL_INLINE void Com_Prv_IPduBasedSigGrpTimeoutAction(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst             rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst           rxSigGrpConstPtr_pcst;
    uint16_least                    idxSigGrp_qu16;

    rxIpduConstPtr_pcst   = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    /* Set the signal group flags to indicate timeout
    * When the signal group is read using function Com_ReceiveSignalGroup(), if signal group is timed
    * out then either previous value or init value is returned based on the action configured
    */
    rxSigGrpConstPtr_pcst = COM_GET_RXSIGGRP_CONSTDATA(rxIpduConstPtr_pcst->idFirstRxSigGrp_uo);

    for (idxSigGrp_qu16 = rxIpduConstPtr_pcst->numOfSigGrp_u16; idxSigGrp_qu16 != COM_ZERO; idxSigGrp_qu16--)
    {
        /* Signal Groups with update-bit have seperate timeout handling
        * Signal Groups without update-bit are marked as timed out, when IPdu times out.
        */
#ifdef COM_RxSigGrpUpdateBit
        if (Com_GetValue(RXSIGGRP,_UPDBITCONF,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8) == COM_FALSE)
#endif
        {
            uint8 timeoutAction_u8;

            timeoutAction_u8 = (uint8)Com_GetValue(RXSIGGRP,_TOACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8);

            if (timeoutAction_u8 != COM_NONE)
            {
                /**
                * TRACE[SWS_Com_00513] If ComRxDataTimeoutAction is set to REPLACE, the AUTOSAR COM module
                * shall replace the values of all included group signals by their ComSignalInitValue,
                * when the reception deadline monitoring timer of a signal group expires.
                * TRACE[SWS_Com_00876] If ComRxDataTimeoutAction is set to SUBSTITUTE,
                * the AUTOSAR COM module shall replace the values of all included group signals by their
                * ComTimeoutSubstitutionValue, when the reception deadline monitoring timer of a signal group expires.
                */
                Com_Prv_RxReplaceSigGrp( rxSigGrpConstPtr_pcst, rxIpduConstPtr_pcst->idMainFunc_uo, timeoutAction_u8 );
            }
            else
            {
                /**
                * TRACE[SWS_Com_00500] If the reception deadline monitoring timer of a signal or signal group expires
                * and the configuration parameter ComRxDataTimeoutAction for this signal or signal group is either
                * omitted or configured to NONE, the AUTOSAR COM module shall not replace the signal or the signals
                * of the signal groups respectively.
                */
            }

            /* even if signal buffer is overwritten with value in timeout-action,
            notification is not required to be invoked due to the below requirement
            that mandates only for successful reception */
            /* TRACE[SWS_Com_00883] For each ComNotification that is configured for a signal or signal group,
            the AUTOSAR COM shall indicate each successful transmission/reception via the configured notifications. */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
            * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
            * monitoring timeout occurred for this signal the same way as if the value has passed
            * the filter criteria. */
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,rxSigGrpConstPtr_pcst->sigGrpRAM_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        rxSigGrpConstPtr_pcst++;
    }

} /* End of Com_Prv_IPduBasedSigGrpTimeoutAction */
#endif /* #if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout) */


#ifdef COM_RxSigUpdateTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_SigBasedTimeoutMonitoring
 Description      : Service to perform timeout processing for rx-Signal with update-bit & timeout
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_SigBasedTimeoutMonitoring(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst                 rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst                  rxSigConstPtr_pcst;
    const Com_SignalTimeoutInfo_tst *   sigTimeOutConstPtr_pcst;
    uint16 *                            sigTimeOutRamPtr_pu16;
#  ifdef COM_CALLBACK_RX
    const Com_Prv_xRxSigVarCfg_tst *    rxSigVarCfg_pcst;
#  endif
    uint16_least                        numOfSig_qu16;
    uint16_least                        idxSig_qu16;
#ifdef COM_RxUpdateTimeoutNotify
    boolean                             callTOSigNotify_b;
#endif

    rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    /* Get the number of signals with update-bit & configured timeout, within this IPDU */
    numOfSig_qu16           = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->numWithUpdateBit_u8;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    sigTimeOutConstPtr_pcst = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->timeoutInfoRef_pcst;
    /* Initialise pointer to timer */
    sigTimeOutRamPtr_pu16   = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->timeoutTicks_pu16;

    for (idxSig_qu16 = numOfSig_qu16; idxSig_qu16 != COM_ZERO; idxSig_qu16--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Reset the callTOSigNotify_b flag before processing next signal */
        callTOSigNotify_b   = COM_FALSE;
#endif
        rxSigConstPtr_pcst  = COM_GET_RXSIG_CONSTDATA(sigTimeOutConstPtr_pcst->idSig_u16);

        /* Decrement the timer, if time out is enabled
        * If FirstTimeOut for signal is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
        * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
        */
        Com_Get_SchM_Enter_Com_RxSigToTicks
        if (((*sigTimeOutRamPtr_pu16) != COM_RXTIMER_MAX) && ((*sigTimeOutRamPtr_pu16) != COM_ZERO))
        {
            --(*sigTimeOutRamPtr_pu16);
        }
        /* Signal has timed out */
        if ((*sigTimeOutRamPtr_pu16) == COM_ZERO)
        {
            uint8 timeoutAction_u8;

            /* Reload the timer */
            (*sigTimeOutRamPtr_pu16) = sigTimeOutConstPtr_pcst->timeout_u16;

            timeoutAction_u8 = (uint8)Com_GetValue(RXSIG,_TOACTION,rxSigConstPtr_pcst->rxSignalFields_u16);

            if (timeoutAction_u8 != COM_NONE)
            {
                /**
                * TRACE[SWS_Com_00470] If ComRxDataTimeoutAction is set to REPLACE,
                * the AUTOSAR COM module shall replace the signal's value by its ComSignalInitValue
                * when the reception deadline monitoring timer of a signal expires.
                * In case the ComSignalInitValue replaces the last received value, the last received
                * value is overwritten and gets lost. Therefore, the AUTOSAR COM module returns the
                * ComSignalInitValue for this signal until a new value is received.
                * TRACE[SWS_Com_00875] If ComRxDataTimeoutAction is set to SUBSTITUTE,
                * the AUTOSAR COM module shall replace the signal's value by its ComTimeoutSubstitutionValue
                * when the reception deadline monitoring timer of a signal expires.
                */
                (void)Com_Prv_RxReplaceSignal(rxSigConstPtr_pcst, rxIpduConstPtr_pcst->idMainFunc_uo, timeoutAction_u8);
            }
            else
            {
                /**
                * TRACE[SWS_Com_00500] If the reception deadline monitoring timer of a signal or signal group expires
                * and the configuration parameter ComRxDataTimeoutAction for this signal or signal group is either
                * omitted or configured to NONE, the AUTOSAR COM module shall not replace the signal or the signals
                * of the signal groups respectively.
                */
            }

            /* even if signal buffer is overwritten with value in timeout-action,
            notification is not required to be invoked due to the below requirement
            that mandates only for successful reception */
            /* TRACE[SWS_Com_00883] For each ComNotification that is configured for a signal or signal group,
            the AUTOSAR COM shall indicate each successful transmission/reception via the configured notifications. */

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the signal timeout notification flag, and
            * call TO notification callback outside the lock */
            callTOSigNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
            * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
            * monitoring timeout occurred for this signal the same way as if the value has passed the
            * filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,(rxSigConstPtr_pcst->sigRAM_pst->rxSigRAMFields_u8),COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        Com_Get_SchM_Exit_Com_RxSigToTicks

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal has timed out,Call the timeout notification for the signal */
        if (callTOSigNotify_b)
        {
            if (sigTimeOutConstPtr_pcst->timeoutNotification_pfct != NULL_PTR)
            {
                Com_Get_SchM_Exit_Com_RxIPduProcess
                /* Notifications are invoked outside the Com locks */
                sigTimeOutConstPtr_pcst->timeoutNotification_pfct();

                Com_Get_SchM_Enter_Com_RxIPduProcess
            }
#  ifdef COM_CALLBACK_RX
            else
            {
                rxSigVarCfg_pcst = COM_GET_RXSIG_VAR_CFG(sigTimeOutConstPtr_pcst->idSig_u16);
                if (rxSigVarCfg_pcst->toutCbk_pcauo != NULL_PTR)
                {
                    Com_Get_SchM_Exit_Com_RxIPduProcess

                    Com_Prv_InvokeRxUserCbks(rxSigVarCfg_pcst->toutCbk_pcauo, rxSigConstPtr_pcst->idHandle_u16);

                    Com_Get_SchM_Enter_Com_RxIPduProcess
                }
            }
#  endif /* end of COM_CALLBACK_RX */
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        sigTimeOutConstPtr_pcst++;
        sigTimeOutRamPtr_pu16++;
    } /* End for loop */

} /* End of Com_Prv_SigBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigUpdateTimeout */


#ifdef COM_RxSigGrpUpdateTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_SigGrpBasedTimeoutMonitoring
 Description      : Service to perform timeout processing for rx-SignalGroups with update-bit & timeout
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_SigGrpBasedTimeoutMonitoring(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst                 rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst               rxSigGrpConstPtr_pcst;
    const Com_SignalTimeoutInfo_tst *   sigTimeOutConstPtr_pcst;
    uint16 *                            sigTimeOutRamPtr_pu16;
#  ifdef COM_CALLBACK_RX
    const Com_Prv_xRxSigGrpVarCfg_tst * rxSigGrpVarCfg_pcst;
#  endif
    uint16_least                        numOfSigGrp_qu16;
    uint16_least                        idxSigGrp_qu16;
#ifdef COM_RxUpdateTimeoutNotify
    /* flag to call the callback functions when the SigGrp times out */
    boolean                             callTOSigGrpNotify_b;
#endif

    rxIpduConstPtr_pcst         = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    /* Get the number of signal groups with update-bit & configured timeout, within this IPDU */
    numOfSigGrp_qu16             = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->numWithUpdateBit_u8;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    sigTimeOutConstPtr_pcst     = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->timeoutInfoRef_pcst;
    /* Initialise pointer to timer */
    sigTimeOutRamPtr_pu16       = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->timeoutTicks_pu16;

    for (idxSigGrp_qu16 = numOfSigGrp_qu16; idxSigGrp_qu16 != COM_ZERO; idxSigGrp_qu16--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Initialise the flag which is used to call the TO notification callback functions */
        callTOSigGrpNotify_b = COM_FALSE;
#endif

        /* Decrement the timer, if time out is enabled
        * If FirstTimeOut for signal group is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
        * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
        */
        Com_Get_SchM_Enter_Com_RxSigGrpToTicks
        if (((*sigTimeOutRamPtr_pu16) != COM_RXTIMER_MAX) && ((*sigTimeOutRamPtr_pu16) != COM_ZERO))
        {
            --(*sigTimeOutRamPtr_pu16);
        }
        /* Signal group has timed out */
        if ((*sigTimeOutRamPtr_pu16) == COM_ZERO)
        {
            uint8 timeoutAction_u8;

            /* Reload the timer */
            (*sigTimeOutRamPtr_pu16) = sigTimeOutConstPtr_pcst->timeout_u16;

            rxSigGrpConstPtr_pcst    = COM_GET_RXSIGGRP_CONSTDATA(sigTimeOutConstPtr_pcst->idSig_u16);

            timeoutAction_u8 = (uint8)Com_GetValue(RXSIGGRP,_TOACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8);

            if (timeoutAction_u8 != COM_NONE)
            {
                /**
                * TRACE[SWS_Com_00513] If ComRxDataTimeoutAction is set to REPLACE, the AUTOSAR COM module
                * shall replace the values of all included group signals by their ComSignalInitValue,
                * when the reception deadline monitoring timer of a signal group expires.
                * TRACE[SWS_Com_00876] If ComRxDataTimeoutAction is set to SUBSTITUTE,
                * the AUTOSAR COM module shall replace the values of all included group signals by their
                * ComTimeoutSubstitutionValue, when the reception deadline monitoring timer of a signal group expires.
                */
                Com_Prv_RxReplaceSigGrp( rxSigGrpConstPtr_pcst, rxIpduConstPtr_pcst->idMainFunc_uo, timeoutAction_u8 );
            }
            else
            {
                /**
                * TRACE[SWS_Com_00500] If the reception deadline monitoring timer of a signal or signal group expires
                * and the configuration parameter ComRxDataTimeoutAction for this signal or signal group is either
                * omitted or configured to NONE, the AUTOSAR COM module shall not replace the signal or the signals
                * of the signal groups respectively.
                */
            }

            /* even if signal buffer is overwritten with value in timeout-action,
            notification is not required to be invoked due to the below requirement
            that mandates only for successful reception */
            /* TRACE[SWS_Com_00883] For each ComNotification that is configured for a signal or signal group,
            the AUTOSAR COM shall indicate each successful transmission/reception via the configured notifications. */

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the flag which is used to call callback notifications signal group with
            * update bit times out*/
            callTOSigGrpNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
            * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
            * monitoring timeout occurred for this signal the same way as if the value has passed
            * the filter criteria.*/
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,rxSigGrpConstPtr_pcst->sigGrpRAM_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        Com_Get_SchM_Exit_Com_RxSigGrpToTicks

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal group has timed out,Call the timeout notification for the signal */
        if (callTOSigGrpNotify_b)
        {
            if (sigTimeOutConstPtr_pcst->timeoutNotification_pfct != NULL_PTR)
            {
                Com_Get_SchM_Exit_Com_RxIPduProcess
                /* Notifications are invoked outside the Com locks */
                sigTimeOutConstPtr_pcst->timeoutNotification_pfct();

                Com_Get_SchM_Enter_Com_RxIPduProcess
            }
#  ifdef COM_CALLBACK_RX
            else
            {
                rxSigGrpVarCfg_pcst = COM_GET_RXSIGGRP_VAR_CFG(sigTimeOutConstPtr_pcst->idSig_u16);
                if (rxSigGrpVarCfg_pcst->toutCbk_pcauo != NULL_PTR)
                {
                    Com_Get_SchM_Exit_Com_RxIPduProcess

                    Com_Prv_InvokeRxUserCbks(rxSigGrpVarCfg_pcst->toutCbk_pcauo, rxSigGrpConstPtr_pcst->idHandle_u16);

                    Com_Get_SchM_Enter_Com_RxIPduProcess
                }
            }
#  endif /* end of COM_CALLBACK_RX */
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        sigTimeOutConstPtr_pcst++;
        sigTimeOutRamPtr_pu16++;
    } /* End for loop */

} /* End of Com_Prv_SigGrpBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */


#ifdef COM_PROVIDE_IPDU_STATUS
/*
 **********************************************************************************************************************
 Function name    : COM_ProvideRxIpduStatus
 Description      : Service returns the status of Rx I-PDU referenced by PduId.
 Parameter        : idPdu_uo -> Rx-Ipdu ID
 Return value     : true - if Ipdu is started, otherwise return false.
 **********************************************************************************************************************
*/
boolean Com_ProvideRxIpduStatus(PduIdType idPdu_uo)
{
    boolean     pduStatus_b;

    pduStatus_b  = COM_FALSE;

# if (COM_PRV_ERROR_HANDLING == STD_ON)
    if (Com_InitStatus_en == COM_UNINIT)
    {
        COM_DET_REPORT_ERROR(COMServiceId_ProvideRxIpduStatus, COM_E_UNINIT);
    }
    else if (!Com_Prv_IsValidRxIpduId(idPdu_uo))
    {
        COM_DET_REPORT_ERROR(COMServiceId_ProvideRxIpduStatus, COM_E_PARAM);
    }
    else
# endif /* end of COM_PRV_ERROR_HANDLING */
    {
        /* If PB variant is selected, then PduId which is passed to this function will be changed
        * to internal Id which is generated through configuration
        * If PC variant is selected, then no mapping table will be used. */

        idPdu_uo = COM_GET_RX_IPDU_ID(idPdu_uo);

        pduStatus_b = Com_Prv_CheckRxIPduStatus(idPdu_uo);
    }

    return(pduStatus_b);

} /* End of Com_ProvideRxIpduStatus */

#endif /* #ifdef COM_PROVIDE_IPDU_STATUS */


#ifdef COM_RxIPduDeferredProcessing
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ProcessDeferredRxIpdu
 Description      : Rx-IPDU processing with DEFERRED signal-processing
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ProcessDeferredRxIpdu(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst     rxIpduConstPtr_pcst;
    Com_RxIpduRam_tpst      rxIpduRamPtr_pst;
    PduInfoType             rxPduInfo_st;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);
    rxIpduRamPtr_pst     = rxIpduConstPtr_pcst->ipduRam_pst;

    rxPduInfo_st.SduDataPtr = COM_GET_DEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo);
    rxPduInfo_st.MetaDataPtr = NULL_PTR;

#ifdef COM_RX_TP_IPDUTYPE
    if (Com_GetValue(RXIPDU,_IS_TP_TYPE,rxIpduConstPtr_pcst->rxIPduFields_u8) == COM_FALSE)
#endif
    {
        Com_Get_SchM_Enter_Com_RxPduBuffer

        rxPduInfo_st.SduLength = rxIpduRamPtr_pst->rxIPduLength_uo;

        /*
        * Copy the data from IPdu buffer to another buffer
        * This is required for data consistency as it is possible that IPdu buffer is updated
        * by Com_RxIndication(), when it is being processed
        * Since all the IPdus are processed sequentially, only one common buffer is sufficient
        */
        Com_ByteCopy(rxPduInfo_st.SduDataPtr, rxIpduConstPtr_pcst->buffPtr_pau8, rxPduInfo_st.SduLength);

#if defined(COM_METADATA_SUPPORT)
        if (Com_GetValue(RXIPDU,_IS_METADATAPDU,rxIpduConstPtr_pcst->rxIPduFields_u8))
        {
            /* Copy the given MetaData into RxMetaData internal buffer */
            Com_ByteCopy(COM_GET_RXMETADATADEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo),
                         &rxIpduRamPtr_pst->rxMetadataBuf_au8[0],
                         COM_GET_RXMETADATA(idPdu_uo)->rxMetaDataLength_u8);

            /* intilializes with received metadata buffer */
            rxPduInfo_st.MetaDataPtr = COM_GET_RXMETADATADEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo);
        }
#endif

        /* Reset the flag after checking the flag
        * In case of defered processing, the flag should be reset under protection */
        Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);

        Com_Get_SchM_Exit_Com_RxPduBuffer

#if defined(COM_RxIPduCallOuts) || defined(COM_RX_IPDUCOUNTER)
        if (Com_Prv_IsValidRxIpdu(idPdu_uo, &rxPduInfo_st))
#endif
        {
            Com_Prv_ProcessRxIPdu(idPdu_uo, &rxPduInfo_st);
        }
    }
#ifdef COM_RX_TP_IPDUTYPE
    else
    {
        if (Com_GetRamValue(RXIPDU,_IS_INVALID,rxIpduRamPtr_pst->rxFlags_u16) == COM_FALSE)
        {
            Com_Get_SchM_Enter_Com_RxPduBuffer

            rxPduInfo_st.SduLength = rxIpduRamPtr_pst->rxIPduLength_uo;

            /*
            * Copy the data from IPdu buffer to another buffer
            * This is required for data consistency as it is possible that IPdu buffer is updated
            * by Com_TpRxIndication(), when it is being processed
            * Since all the IPdus are processed sequentially, only one common buffer is sufficient
            */
            Com_ByteCopy(rxPduInfo_st.SduDataPtr, rxIpduConstPtr_pcst->buffPtr_pau8, rxPduInfo_st.SduLength);

#if defined(COM_METADATA_SUPPORT)
            if (Com_GetValue(RXIPDU,_IS_METADATAPDU,rxIpduConstPtr_pcst->rxIPduFields_u8))
            {
                /* Copy the given MetaData into RxMetaData internal buffer */
                Com_ByteCopy(COM_GET_RXMETADATADEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo),
                             &rxIpduRamPtr_pst->rxMetadataBuf_au8[0],
                             COM_GET_RXMETADATA(idPdu_uo)->rxMetaDataLength_u8);

                /* intilializes with received metadata buffer */
                rxPduInfo_st.MetaDataPtr = COM_GET_RXMETADATADEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo);
            }
#endif

            /* Reset the flag after checking the flag
            * In case of defered processing, the flag should be reset under protection */
            Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);

            Com_Get_SchM_Exit_Com_RxPduBuffer

            /* IPDU callout and counter is already processed in Com_TpRxIndication */

            Com_Prv_ProcessRxIPdu(idPdu_uo, &rxPduInfo_st);
        }
        else
        {
            Com_Get_SchM_Enter_Com_RxPduBuffer

            Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);

            Com_SetRamValue(RXIPDU,_IS_INVALID,rxIpduRamPtr_pst->rxFlags_u16,COM_FALSE);

            Com_Get_SchM_Exit_Com_RxPduBuffer

# ifdef COM_RXIPDU_TP_INVALIDATION
            if (Com_GetValue(RXIPDU,_TP_INV_CFG,rxIpduConstPtr_pcst->rxIPduFields_u8))
            {
                Com_Prv_ExecuteRxInvalidActions(idPdu_uo);
            }
# endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */
        }
    }
#endif /* end of #ifdef COM_RX_TP_IPDUTYPE */
}

#endif /* end of # ifdef COM_RxIPduDeferredProcessing */


#ifdef COM_RXIPDU_TP_INVALIDATION

/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signals and signal groups
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
void Com_Prv_ExecuteRxInvalidActions(PduIdType idPdu_uo)
{
#ifdef COM_RxSigInvalid
    Com_Prv_ExecuteRxSigInvalidActions(idPdu_uo);
#endif

#ifdef COM_RxSigGrpInvalid
    Com_Prv_ExecuteRxSigGrpInvalidActions(idPdu_uo);
#endif

#if defined(COM_RxIPduNotification) || defined(COM_RxSignalNotify) || defined(COM_RxSignalGrpNotify)
    Com_Prv_InvokeRxNotifications(idPdu_uo);
#endif

}


#ifdef COM_RxSigInvalid
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxSigInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signals
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ExecuteRxSigInvalidActions(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst          rxSigConstPtr_pcst;
    uint16_least                idxIdSig_qu16;
    uint16_least                idMaxRxSig_qu16;
#ifdef COM_RxSigUpdateTimeout
    uint16_least                idxSigTout_qu16;
    uint8                       ipduUpdateBitStatus_u8;
    uint8                       sigUpdateBitStatus_u8;
#endif
    uint8                       invAction_u8;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);

#ifdef COM_RxSigUpdateTimeout
    /* If this IPDU has signals with update-bits , initialise the pointers
    * Separate deadline monitoring should be performed for signals with update-bit
    * Deadline monitoring should not be done if it is disabled
    */
    /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
    * to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact the
    * system behaviour. Hence suppressed. */
    if ((rxIpduConstPtr_pcst->signalTimeoutRef_pcst != NULL_PTR) && (COM_CheckRxIPduDMStatus(idPdu_uo)))
    {

        /* Update the variable UpdateBitStatus with value COM_UPDATEBIT_APPLICABLE
        * ie at least one of the signal within the IPDU is configured with both update-bit.
        */
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_APPLICABLE;
    }
    else
    {
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_NOT_APPLICABLE;
    }

    /* Initialize the variable to be used to refer the first signal timeout configuration */
    idxSigTout_qu16 = COM_ZERO;
#endif /* #ifdef COM_RxSigUpdateTimeout */

    idxIdSig_qu16       = rxIpduConstPtr_pcst->idRxSig_uo;
    idMaxRxSig_qu16     = idxIdSig_qu16 + rxIpduConstPtr_pcst->numOfSig_u16;

    rxSigConstPtr_pcst  = COM_GET_RXSIG_CONSTDATA(idxIdSig_qu16);

    for ( ; idxIdSig_qu16 < idMaxRxSig_qu16; idxIdSig_qu16++ )
    {

#ifdef COM_RxSigUpdateTimeout
        sigUpdateBitStatus_u8 = ipduUpdateBitStatus_u8;
#endif

        invAction_u8 = (uint8)Com_GetValue(RXSIG,_INVACTION,rxSigConstPtr_pcst->rxSignalFields_u16);

        if (invAction_u8 == COM_REPLACE)
        {
            /* TRACE[SWS_Com_00681] If the configured ComSignalDataInvalidValue is received for a signal and
            * the ComDataInvalidAction is configured to REPLACE for this signal,
            * the AUTOSAR COM module shall replace the signal's value by its configured ComSignalInitValue.
            * After the replacement, the normal signal processing like filtering and
            * notification shall take place as if the ComSignalInitValue would have been received
            * instead of the ComSignalDataInvalidValue. */

            if (Com_Prv_IsRxSigReplacedToInit((Com_SignalIdType)idxIdSig_qu16))
            {
                /* If sigUpdateBitStatus_u8 is
                * COM_UPDATEBIT_NOT_APPLICABLE(0x0), then it remains unchanged.
                * COM_UPDATEBIT_APPLICABLE(0x1), then it is changed to COM_UPDATEBIT_SET(0x2) here. */
#ifdef COM_RxSigUpdateTimeout
                sigUpdateBitStatus_u8 *= COM_UPDATEBIT_SET;
#endif

                /* Set to invoke configured signal-ComNotification later */
#ifdef COM_RxSignalNotify
                Com_SetRamValue(RXSIG,_SIGNOTIF,(rxSigConstPtr_pcst->sigRAM_pst->rxSigRAMFields_u8),COM_TRUE);
#ifdef COM_PRV_ENABLECONFIGINTERFACES
                Com_SetRamValue(RXSIGCFG,_SIGNOTIF,
                               (*(Com_GlobalConfig_pcst->rxSigCfg_pcst[idxIdSig_qu16].rxSigRAMFields_pu8)),COM_TRUE);
#endif
#endif
            }

        }
#  ifdef COM_RxSigInvalidNotify
        else if (invAction_u8 == COM_NOTIFY)
        {
            /* TRACE[SWS_Com_00680] If the configured ComSignalDataInvalidValue is received for a signal and
            * the ComDataInvalidAction is configured to NOTIFY for this signal,
            * the AUTOSAR COM module shall notify the RTE via the configured ComInvalidNotification function.
            * In this case, no other signal processing like filtering or
            * the normal signal indication shall take place.
            * TRACE[SWS_Com_00717] If the configured ComSignalDataInvalidValue is received for a signal and
            * its ComDataInvalidAction is configured to NOTIFY,
            * the AUTOSAR COM module shall not store the received ComSignalDataInvalidValue
            * into the signal object.
            * The next call to Com_ReceiveSignal will return the last valid received signal or the
            * ComSignalInitValue in case no signal was received yet respectively. */

            if (rxSigConstPtr_pcst->invalidNotification_pfct != NULL_PTR)
            {
                rxSigConstPtr_pcst->invalidNotification_pfct();
            }
#  ifdef COM_CALLBACK_RX
            else
            {
                const Com_Prv_xRxSigVarCfg_tst * rxSigVarCfg_pcst;

                rxSigVarCfg_pcst = COM_GET_RXSIG_VAR_CFG(idxIdSig_qu16);
                if (rxSigVarCfg_pcst->invCbk_pcauo != NULL_PTR)
                {
                    Com_Prv_InvokeRxUserCbks(rxSigVarCfg_pcst->invCbk_pcauo, rxSigConstPtr_pcst->idHandle_u16);
                }
            }
#  endif /* end of COM_CALLBACK_RX */
        }
#  endif /* #ifdef COM_RxSigInvalidNotify */
        else
        {
            /* invAction_u8 is not confgured. Nothing to do. */
        }

#ifdef COM_RxSigUpdateTimeout
        if (sigUpdateBitStatus_u8 != COM_UPDATEBIT_NOT_APPLICABLE)
        {
            Com_Prv_LoadSigTimeoutValue((Com_SignalIdType)idxIdSig_qu16, sigUpdateBitStatus_u8, &idxSigTout_qu16);
        }
#endif /* end of #ifdef COM_RxSigUpdateTimeout */

        rxSigConstPtr_pcst++;

    }
}
#endif /* COM_RxSigInvalid */


#ifdef COM_RxSigGrpInvalid
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxSigGrpInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signal groups
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ExecuteRxSigGrpInvalidActions(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst             rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst           rxSigGrpConstPtr_pcst;
    uint16_least                    idxIdSigGrp_qu16;
    uint16_least                    idMaxSigGrp_qu16;
#ifdef COM_RxSigGrpUpdateTimeout
    uint16_least                    idxSigTout_qu16;
    uint8                           ipduUpdateBitStatus_u8;
    uint8                           sigUpdateBitStatus_u8;
#endif
    uint8                           invalidAction_u8;
    Com_MainFunc_tuo                idRxMainFunc_uo;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);

#ifdef COM_RxSigGrpUpdateTimeout
    /* If this IPDU has signals with update-bits , initialise the pointers
    * Separate deadline monitoring should be performed for signals with update-bit
    * Deadline monitoring should not be done if it is disabled
    */
    /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
    * to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact the
    * system behaviour. Hence suppressed. */
    if ((rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst != NULL_PTR) && (COM_CheckRxIPduDMStatus(idPdu_uo)))
    {

        /* Update the variable UpdateBitStatus with value COM_UPDATEBIT_APPLICABLE
        * ie at least one of the signal within the IPDU is configured with both update-bit.
        */
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_APPLICABLE;
    }
    else
    {
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_NOT_APPLICABLE;
    }

    /* Initialize the variable to be used to refer the first signal timeout configuration */
    idxSigTout_qu16 = COM_ZERO;

#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

    idRxMainFunc_uo     = rxIpduConstPtr_pcst->idMainFunc_uo;

    idxIdSigGrp_qu16    = rxIpduConstPtr_pcst->idFirstRxSigGrp_uo;
    idMaxSigGrp_qu16    = idxIdSigGrp_qu16 + rxIpduConstPtr_pcst->numOfSigGrp_u16;

    rxSigGrpConstPtr_pcst  = COM_GET_RXSIGGRP_CONSTDATA(idxIdSigGrp_qu16);

    /* Start processing for signal groups. */
    for ( ; idxIdSigGrp_qu16 < idMaxSigGrp_qu16; idxIdSigGrp_qu16++)
    {
#ifdef COM_RxSigGrpUpdateTimeout
        sigUpdateBitStatus_u8 = ipduUpdateBitStatus_u8;
#endif

        invalidAction_u8 = (uint8)Com_GetValue(RXSIGGRP,_INVACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8);

        if (invalidAction_u8 == COM_REPLACE)
        {
            /* Replace all the GroupSignals with Initial value */
            Com_Prv_RxReplaceSigGrp(rxSigGrpConstPtr_pcst, idRxMainFunc_uo, COM_REPLACE);

            /* If sigUpdateBitStatus_u8 is
            * COM_UPDATEBIT_NOT_APPLICABLE(0x0), then it remains unchanged.
            * COM_UPDATEBIT_APPLICABLE(0x1), then it is changed to COM_UPDATEBIT_SET(0x2) here. */
#ifdef COM_RxSigGrpUpdateTimeout
            sigUpdateBitStatus_u8 <<= COM_ONE;
#endif

            /* Set _SIGNOTIF flag to invoke configured SignalGroup-ComNotification */
#ifdef COM_RxSignalGrpNotify
            Com_SetRamValue(RXSIGGRP,_SIGNOTIF,rxSigGrpConstPtr_pcst->sigGrpRAM_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#ifdef COM_PRV_ENABLECONFIGINTERFACES
            Com_SetRamValue(RXSIGGRPCFG,_SIGNOTIF,
                         *(Com_GlobalConfig_pcst->rxSigGrpCfg_pcst[idxIdSigGrp_qu16].rxSigGrpRAMFields_pu8),COM_TRUE);
#endif
#endif
        }
#ifdef COM_RxSigGrpInvalidNotify
        else if (invalidAction_u8 == COM_NOTIFY)
        {
            /* Invoke invalid notification function */
            if (rxSigGrpConstPtr_pcst->invalidNotification_pfct != NULL_PTR)
            {
                rxSigGrpConstPtr_pcst->invalidNotification_pfct();
            }
#  ifdef COM_CALLBACK_RX
            else
            {
                const Com_Prv_xRxSigGrpVarCfg_tst * rxSigGrpVarCfg_pcst;

                rxSigGrpVarCfg_pcst = COM_GET_RXSIGGRP_VAR_CFG(idxIdSigGrp_qu16);
                if (rxSigGrpVarCfg_pcst->invCbk_pcauo != NULL_PTR)
                {
                    Com_Prv_InvokeRxUserCbks(rxSigGrpVarCfg_pcst->invCbk_pcauo, rxSigGrpConstPtr_pcst->idHandle_u16);
                }
            }
#  endif /* end of COM_CALLBACK_RX */
        }
#endif /* #ifdef COM_RxSigGrpInvalidNotify */
        else
        {
            /* do nothing */
        }

#ifdef COM_RxSigGrpUpdateTimeout
        if (sigUpdateBitStatus_u8 != COM_UPDATEBIT_NOT_APPLICABLE)
        {
            Com_Prv_LoadSigGrpTimeoutValue((Com_SignalGroupIdType)idxIdSigGrp_qu16,
                                            sigUpdateBitStatus_u8, &idxSigTout_qu16);
        }
#endif /* end of #ifdef COM_RxSigGrpUpdateTimeout */

        rxSigGrpConstPtr_pcst++;
    }
}
#endif /* COM_RxSigGrpInvalid */

#endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */

#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"

